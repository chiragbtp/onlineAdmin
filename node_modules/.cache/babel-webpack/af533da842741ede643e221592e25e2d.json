{"ast":null,"code":"/**\n* @license Angular v10.1.0-next.6+7.sha-aaa1d8e\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  Zone.__load_patch('jasmine', function (global, Zone, api) {\n    var __extends = function __extends(d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n    if (!Zone) throw new Error('Missing: zone.js');\n\n    if (typeof jest !== 'undefined') {\n      // return if jasmine is a light implementation inside jest\n      // in this case, we are running inside jest not jasmine\n      return;\n    }\n\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n      return;\n    }\n\n    jasmine['__zone_patch__'] = true;\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n    var ambientZone = Zone.current; // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n    // error if any asynchronous operations are attempted inside of a `describe` but outside of\n    // a `beforeEach` or `it`.\n\n    var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n    var symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n    var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n\n    var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n    var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n    if (!ignoreUnhandledRejection) {\n      var globalErrors = jasmine.GlobalErrors;\n\n      if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n        jasmine[symbol('GlobalErrors')] = globalErrors;\n\n        jasmine.GlobalErrors = function () {\n          var instance = new globalErrors();\n          var originalInstall = instance.install;\n\n          if (originalInstall && !instance[symbol('install')]) {\n            instance[symbol('install')] = originalInstall;\n\n            instance.install = function () {\n              var originalHandlers = process.listeners('unhandledRejection');\n              var r = originalInstall.apply(this, arguments);\n              process.removeAllListeners('unhandledRejection');\n\n              if (originalHandlers) {\n                originalHandlers.forEach(function (h) {\n                  return process.on('unhandledRejection', h);\n                });\n              }\n\n              return r;\n            };\n          }\n\n          return instance;\n        };\n      }\n    } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n    var jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n\n      jasmineEnv[methodName] = function (description, specDefinitions) {\n        return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n      };\n    });\n    ['it', 'xit', 'fit'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n        arguments[1] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (specDefinitions, timeout) {\n        arguments[0] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n\n    if (!disablePatchingJasmineClock) {\n      // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n      // they can work properly in FakeAsyncTest\n      var originalClockFn = jasmine[symbol('clock')] = jasmine['clock'];\n\n      jasmine['clock'] = function () {\n        var clock = originalClockFn.apply(this, arguments);\n\n        if (!clock[symbol('patched')]) {\n          clock[symbol('patched')] = symbol('patched');\n          var originalTick = clock[symbol('tick')] = clock.tick;\n\n          clock.tick = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n            }\n\n            return originalTick.apply(this, arguments);\n          };\n\n          var originalMockDate = clock[symbol('mockDate')] = clock.mockDate;\n\n          clock.mockDate = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n              return fakeAsyncZoneSpec.setCurrentRealTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n            }\n\n            return originalMockDate.apply(this, arguments);\n          }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n          if (enableAutoFakeAsyncWhenClockPatched) {\n            ['install', 'uninstall'].forEach(function (methodName) {\n              var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n              clock[methodName] = function () {\n                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n                if (FakeAsyncTestZoneSpec) {\n                  jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                  return;\n                }\n\n                return originalClockFn.apply(this, arguments);\n              };\n            });\n          }\n        }\n\n        return clock;\n      };\n    } // monkey patch createSpyObj to make properties enumerable to true\n\n\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n      var originalCreateSpyObj = jasmine.createSpyObj;\n      jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n\n      jasmine.createSpyObj = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var propertyNames = args.length >= 3 ? args[2] : null;\n        var spyObj;\n\n        if (propertyNames) {\n          var defineProperty = Object.defineProperty;\n\n          Object.defineProperty = function (obj, p, attributes) {\n            return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n              configurable: true,\n              enumerable: true\n            }));\n          };\n\n          try {\n            spyObj = originalCreateSpyObj.apply(this, args);\n          } finally {\n            Object.defineProperty = defineProperty;\n          }\n        } else {\n          spyObj = originalCreateSpyObj.apply(this, args);\n        }\n\n        return spyObj;\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(describeBody) {\n      return function () {\n        return syncZone.run(describeBody, this, arguments);\n      };\n    }\n\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n      var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n      var testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n      var testProxyZone = queueRunner.testProxyZone;\n\n      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n        // auto run a fakeAsync\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      if (done) {\n        return testProxyZone.run(testBody, applyThis, [done]);\n      } else {\n        return testProxyZone.run(testBody, applyThis);\n      }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n\n\n    function wrapTestInZone(testBody) {\n      // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jasmine will\n      // think that all functions are sync or async.\n      return testBody && (testBody.length ? function (done) {\n        return runInTestZone(testBody, this, this.queueRunner, done);\n      } : function () {\n        return runInTestZone(testBody, this, this.queueRunner);\n      });\n    }\n\n    var QueueRunner = jasmine.QueueRunner;\n\n    jasmine.QueueRunner = function (_super) {\n      __extends(ZoneQueueRunner, _super);\n\n      function ZoneQueueRunner(attrs) {\n        var _this = this;\n\n        if (attrs.onComplete) {\n          attrs.onComplete = function (fn) {\n            return function () {\n              // All functions are done, clear the test zone.\n              _this.testProxyZone = null;\n              _this.testProxyZoneSpec = null;\n              ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n            };\n          }(attrs.onComplete);\n        }\n\n        var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n        var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n        if (nativeSetTimeout) {\n          // should run setTimeout inside jasmine outside of zone\n          attrs.timeout = {\n            setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n          };\n        } // create a userContext to hold the queueRunner itself\n        // so we can access the testProxy in it/xit/beforeEach ...\n\n\n        if (jasmine.UserContext) {\n          if (!attrs.userContext) {\n            attrs.userContext = new jasmine.UserContext();\n          }\n\n          attrs.userContext.queueRunner = this;\n        } else {\n          if (!attrs.userContext) {\n            attrs.userContext = {};\n          }\n\n          attrs.userContext.queueRunner = this;\n        } // patch attrs.onException\n\n\n        var onException = attrs.onException;\n\n        attrs.onException = function (error) {\n          if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n            // jasmine timeout, we can make the error message more\n            // reasonable to tell what tasks are pending\n            var proxyZoneSpec = this && this.testProxyZoneSpec;\n\n            if (proxyZoneSpec) {\n              var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n              try {\n                // try catch here in case error.message is not writable\n                error.message += pendingTasksInfo;\n              } catch (err) {}\n            }\n          }\n\n          if (onException) {\n            onException.call(this, error);\n          }\n        };\n\n        _super.call(this, attrs);\n      }\n\n      ZoneQueueRunner.prototype.execute = function () {\n        var _this2 = this;\n\n        var zone = Zone.current;\n        var isChildOfAmbientZone = false;\n\n        while (zone) {\n          if (zone === ambientZone) {\n            isChildOfAmbientZone = true;\n            break;\n          }\n\n          zone = zone.parent;\n        }\n\n        if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n        // It will be a proxy zone, so that the tests function can retroactively install\n        // different zones.\n        // Example:\n        //   - In beforeEach() do childZone = Zone.current.fork(...);\n        //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n        //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n        //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n        //     fakeAsync behavior to the childZone.\n\n        this.testProxyZoneSpec = new ProxyZoneSpec();\n        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n        if (!Zone.currentTask) {\n          // if we are not running in a task then if someone would register a\n          // element.addEventListener and then calling element.click() the\n          // addEventListener callback would think that it is the top most task and would\n          // drain the microtask queue on element.click() which would be incorrect.\n          // For this reason we always force a task when running jasmine tests.\n          Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n            return QueueRunner.prototype.execute.call(_this2);\n          });\n        } else {\n          _super.prototype.execute.call(this);\n        }\n      };\n\n      return ZoneQueueRunner;\n    }(QueueRunner);\n  });\n});","map":{"version":3,"sources":["/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/zone.js/fesm2015/jasmine-patch.js"],"names":["factory","define","amd","Zone","__load_patch","global","api","__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Error","jest","jasmine","SyncTestZoneSpec","ProxyZoneSpec","ambientZone","current","syncZone","fork","symbol","__symbol__","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors","GlobalErrors","instance","originalInstall","install","originalHandlers","process","listeners","r","apply","arguments","removeAllListeners","forEach","h","on","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","call","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn","clock","originalTick","tick","fakeAsyncZoneSpec","get","originalMockDate","mockDate","dateTime","length","Date","setCurrentRealTime","getTime","FakeAsyncTestZoneSpec","originalCreateSpyObj","createSpyObj","args","Array","slice","propertyNames","spyObj","defineProperty","obj","attributes","assign","configurable","enumerable","describeBody","run","runInTestZone","testBody","applyThis","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","error","message","proxyZoneSpec","pendingTasksInfo","getAndClearPendingTasksInfo","err","execute","zone","isChildOfAmbientZone","parent","name","currentTask"],"mappings":"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","sourcesContent":["/**\n* @license Angular v10.1.0-next.6+7.sha-aaa1d8e\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n    factory();\n}((function () { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jasmine', (global, Zone, api) => {\n        const __extends = function (d, b) {\n            for (const p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() {\n                this.constructor = d;\n            }\n            d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        const ambientZone = Zone.current;\n        // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n        // error if any asynchronous operations are attempted inside of a `describe` but outside of\n        // a `beforeEach` or `it`.\n        const syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n        const symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n        // automatically disable the auto jump into fakeAsync feature\n        const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            ((global[symbol('fakeAsyncPatchLock')] === true) ||\n                (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n        const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            const globalErrors = jasmine.GlobalErrors;\n            if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors;\n                jasmine.GlobalErrors = function () {\n                    const instance = new globalErrors();\n                    const originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            const originalHandlers = process.listeners('unhandledRejection');\n                            const r = originalInstall.apply(this, arguments);\n                            process.removeAllListeners('unhandledRejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach(h => process.on('unhandledRejection', h));\n                            }\n                            return r;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        const jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach(methodName => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n            let originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            const originalClockFn = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                const clock = originalClockFn.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    const originalTick = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick.apply(this, arguments);\n                    };\n                    const originalMockDate = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setCurrentRealTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                                arguments);\n                        }\n                        return originalMockDate.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach(methodName => {\n                            const originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        // monkey patch createSpyObj to make properties enumerable to true\n        if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n            const originalCreateSpyObj = jasmine.createSpyObj;\n            jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n            jasmine.createSpyObj = function () {\n                const args = Array.prototype.slice.call(arguments);\n                const propertyNames = args.length >= 3 ? args[2] : null;\n                let spyObj;\n                if (propertyNames) {\n                    const defineProperty = Object.defineProperty;\n                    Object.defineProperty = function (obj, p, attributes) {\n                        return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));\n                    };\n                    try {\n                        spyObj = originalCreateSpyObj.apply(this, args);\n                    }\n                    finally {\n                        Object.defineProperty = defineProperty;\n                    }\n                }\n                else {\n                    spyObj = originalCreateSpyObj.apply(this, args);\n                }\n                return spyObj;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(describeBody) {\n            return function () {\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            const isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            const testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n            const testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody && (testBody.length ? function (done) {\n                return runInTestZone(testBody, this, this.queueRunner, done);\n            } : function () {\n                return runInTestZone(testBody, this, this.queueRunner);\n            }));\n        }\n        const QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                if (attrs.onComplete) {\n                    attrs.onComplete = (fn => () => {\n                        // All functions are done, clear the test zone.\n                        this.testProxyZone = null;\n                        this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    })(attrs.onComplete);\n                }\n                const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                const onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        const proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) {\n                            }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                let zone = Zone.current;\n                let isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n\n})));\n"]},"metadata":{},"sourceType":"script"}