{"ast":null,"code":"import _createClass from \"/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { InjectionToken, Injectable, Inject, Component, ChangeDetectionStrategy, ChangeDetectorRef, EventEmitter, ElementRef, Renderer2, Input, Output, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/models/notifier-notification.model.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Notification\n *\n * This class describes the structure of a notifiction, including all information it needs to live, and everyone else needs to work with it.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction NotifierContainerComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r3 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 1);\n    ɵngcc0.ɵɵelementStart(1, \"notifier-notification\", 2);\n    ɵngcc0.ɵɵlistener(\"ready\", function NotifierContainerComponent_li_1_Template_notifier_notification_ready_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ctx_r2.onNotificationReady($event);\n    })(\"dismiss\", function NotifierContainerComponent_li_1_Template_notifier_notification_dismiss_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      var ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.onNotificationDismiss($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var notification_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"notification\", notification_r1);\n  }\n}\n\nvar _c0 = function _c0(a0) {\n  return {\n    notification: a0\n  };\n};\n\nfunction NotifierNotificationComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0, 2);\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.notification.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c0, ctx_r0.notification));\n  }\n}\n\nfunction NotifierNotificationComponent_ng_template_1_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 5);\n    ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_ng_template_1_button_2_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      var ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r4.onClickDismiss();\n    });\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(1, \"svg\", 6);\n    ɵngcc0.ɵɵelement(2, \"path\", 7);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction NotifierNotificationComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"p\", 3);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(2, NotifierNotificationComponent_ng_template_1_button_2_Template, 3, 0, \"button\", 4);\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2.notification.message);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.config.behaviour.showDismissButton);\n  }\n}\n\nvar NotifierNotification =\n/**\n * Constructor\n *\n * @param {?} options Notifier options\n */\nfunction NotifierNotification(options) {\n  _classCallCheck(this, NotifierNotification);\n\n  /**\n   * The template to customize\n   * the appearance of the notification\n   */\n  this.template = null;\n  Object.assign(this, options); // If not set manually, we have to create a unique notification ID by ourselves. The ID generation relies on the current browser\n  // datetime in ms, in praticular the moment this notification gets constructed. Concurrency, and thus two IDs being the exact same,\n  // is not possible due to the action queue concept.\n\n  if (options.id === undefined) {\n    this.id = \"ID_\".concat(new Date().getTime());\n  }\n};\n\nif (false) {\n  /**\n   * Unique notification ID, can be set manually to control the notification from outside later on\n   * @type {?}\n   */\n  NotifierNotification.prototype.id;\n  /**\n   * Notification type, will be used for constructing an appropriate class name\n   * @type {?}\n   */\n\n  NotifierNotification.prototype.type;\n  /**\n   * Notification message\n   * @type {?}\n   */\n\n  NotifierNotification.prototype.message;\n  /**\n   * The template to customize\n   * the appearance of the notification\n   * @type {?}\n   */\n\n  NotifierNotification.prototype.template;\n  /**\n   * Component reference of this notification, created and set during creation time\n   * @type {?}\n   */\n\n  NotifierNotification.prototype.component;\n}\n/**\n * Notifiction options\n *\n * This interface describes which information are needed to create a new notification, or in other words, which information the external API\n * call must provide.\n * @record\n */\n\n\nfunction NotifierNotificationOptions() {}\n\nif (false) {\n  /**\n   * Notification ID, optional\n   * @type {?|undefined}\n   */\n  NotifierNotificationOptions.prototype.id;\n  /**\n   * Notification type\n   * @type {?}\n   */\n\n  NotifierNotificationOptions.prototype.type;\n  /**\n   * Notificatin message\n   * @type {?}\n   */\n\n  NotifierNotificationOptions.prototype.message;\n  /**\n   * The template to customize\n   * the appearance of the notification\n   * @type {?|undefined}\n   */\n\n  NotifierNotificationOptions.prototype.template;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/models/notifier-config.model.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Notifier options\n * @record\n */\n\n\nfunction NotifierOptions() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  NotifierOptions.prototype.animations;\n  /** @type {?|undefined} */\n\n  NotifierOptions.prototype.behaviour;\n  /** @type {?|undefined} */\n\n  NotifierOptions.prototype.position;\n  /** @type {?|undefined} */\n\n  NotifierOptions.prototype.theme;\n}\n/**\n * Notifier configuration\n *\n * The notifier configuration defines what notifications look like, how they behave, and how they get animated. It is a global\n * configuration, which means that it only can be set once (at the beginning), and cannot be changed afterwards. Aligning to the world of\n * Angular, this configuration can be provided in the root app module - alternatively, a meaningful default configuration will be used.\n */\n\n\nvar NotifierConfig =\n/**\n * Constructor\n *\n * @param {?=} customOptions\n */\nfunction NotifierConfig() {\n  var customOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  _classCallCheck(this, NotifierConfig);\n\n  // Set default values\n  this.animations = {\n    enabled: true,\n    hide: {\n      easing: 'ease',\n      offset: 50,\n      preset: 'fade',\n      speed: 300\n    },\n    overlap: 150,\n    shift: {\n      easing: 'ease',\n      speed: 300\n    },\n    show: {\n      easing: 'ease',\n      preset: 'slide',\n      speed: 300\n    }\n  };\n  this.behaviour = {\n    autoHide: 7000,\n    onClick: false,\n    onMouseover: 'pauseAutoHide',\n    showDismissButton: true,\n    stacking: 4\n  };\n  this.position = {\n    horizontal: {\n      distance: 12,\n      position: 'left'\n    },\n    vertical: {\n      distance: 12,\n      gap: 10,\n      position: 'bottom'\n    }\n  };\n  this.theme = 'material'; // The following merges the custom options into the notifier config, respecting the already set default values\n  // This linear, more explicit and code-sizy workflow is preferred here over a recursive one (because we know the object structure)\n  // Technical sidenote: Objects are merged, other types of values simply overwritten / copied\n\n  if (customOptions.theme !== undefined) {\n    this.theme = customOptions.theme;\n  }\n\n  if (customOptions.animations !== undefined) {\n    if (customOptions.animations.enabled !== undefined) {\n      this.animations.enabled = customOptions.animations.enabled;\n    }\n\n    if (customOptions.animations.overlap !== undefined) {\n      this.animations.overlap = customOptions.animations.overlap;\n    }\n\n    if (customOptions.animations.hide !== undefined) {\n      Object.assign(this.animations.hide, customOptions.animations.hide);\n    }\n\n    if (customOptions.animations.shift !== undefined) {\n      Object.assign(this.animations.shift, customOptions.animations.shift);\n    }\n\n    if (customOptions.animations.show !== undefined) {\n      Object.assign(this.animations.show, customOptions.animations.show);\n    }\n  }\n\n  if (customOptions.behaviour !== undefined) {\n    Object.assign(this.behaviour, customOptions.behaviour);\n  }\n\n  if (customOptions.position !== undefined) {\n    if (customOptions.position.horizontal !== undefined) {\n      Object.assign(this.position.horizontal, customOptions.position.horizontal);\n    }\n\n    if (customOptions.position.vertical !== undefined) {\n      Object.assign(this.position.vertical, customOptions.position.vertical);\n    }\n  }\n};\n\nif (false) {\n  /**\n   * Customize animations\n   * @type {?}\n   */\n  NotifierConfig.prototype.animations;\n  /**\n   * Customize behaviour\n   * @type {?}\n   */\n\n  NotifierConfig.prototype.behaviour;\n  /**\n   * Customize positioning\n   * @type {?}\n   */\n\n  NotifierConfig.prototype.position;\n  /**\n   * Customize theming\n   * @type {?}\n   */\n\n  NotifierConfig.prototype.theme;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/notifier.tokens.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Injection Token for notifier options\n * @type {?}\n */\n\n\nvar NotifierOptionsToken = new InjectionToken('[angular-notifier] Notifier Options');\n/**\n * Injection Token for notifier configuration\n * @type {?}\n */\n\nvar NotifierConfigToken = new InjectionToken('[anuglar-notifier] Notifier Config');\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/services/notifier-queue.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\n\nvar NotifierQueueService = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   */\n  function NotifierQueueService() {\n    _classCallCheck(this, NotifierQueueService);\n\n    this.actionStream = new Subject();\n    this.actionQueue = [];\n    this.isActionInProgress = false;\n  }\n  /**\n   * Push a new action to the queue, and try to run it\n   *\n   * @param {?} action Action object\n   * @return {?}\n   */\n\n\n  _createClass(NotifierQueueService, [{\n    key: \"push\",\n    value: function push(action) {\n      this.actionQueue.push(action);\n      this.tryToRunNextAction();\n    }\n    /**\n     * Continue with the next action (called when the current action is finished)\n     * @return {?}\n     */\n\n  }, {\n    key: \"continue\",\n    value: function _continue() {\n      this.isActionInProgress = false;\n      this.tryToRunNextAction();\n    }\n    /**\n     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"tryToRunNextAction\",\n    value: function tryToRunNextAction() {\n      if (this.isActionInProgress || this.actionQueue.length === 0) {\n        return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n      }\n\n      this.isActionInProgress = true;\n      this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n    }\n  }]);\n\n  return NotifierQueueService;\n}();\n\nNotifierQueueService.ɵfac = function NotifierQueueService_Factory(t) {\n  return new (t || NotifierQueueService)();\n};\n\nNotifierQueueService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: NotifierQueueService,\n  factory: NotifierQueueService.ɵfac\n});\n/** @nocollapse */\n\nNotifierQueueService.ctorParameters = function () {\n  return [];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(NotifierQueueService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * Stream of actions, subscribable from outside\n   * @type {?}\n   */\n  NotifierQueueService.prototype.actionStream;\n  /**\n   * Queue of actions\n   * @type {?}\n   * @private\n   */\n\n  NotifierQueueService.prototype.actionQueue;\n  /**\n   * Flag, true if some action is currently in progress\n   * @type {?}\n   * @private\n   */\n\n  NotifierQueueService.prototype.isActionInProgress;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/services/notifier.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Notifier service\n *\n * This service provides access to the public notifier API. Once injected into a component, directive, pipe, service, or any other building\n * block of an applications, it can be used to show new notifications, and hide existing ones. Internally, it transforms API calls into\n * actions, which then get thrown into the action queue - eventually being processed at the right moment.\n */\n\n\nvar NotifierService = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   *\n   * @param {?} notifierQueueService Notifier queue service\n   * @param {?} config               Notifier configuration, optionally injected as a dependency\n   */\n  function NotifierService(notifierQueueService, config) {\n    _classCallCheck(this, NotifierService);\n\n    this.queueService = notifierQueueService;\n    this.config = config;\n  }\n  /**\n   * Get the notifier configuration\n   *\n   * @return {?} Notifier configuration\n   */\n\n\n  _createClass(NotifierService, [{\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.config;\n    }\n    /**\n     * API: Show a new notification\n     *\n     * @param {?} notificationOptions Notification options\n     * @return {?}\n     */\n\n  }, {\n    key: \"show\",\n    value: function show(notificationOptions) {\n      this.queueService.push({\n        payload: notificationOptions,\n        type: 'SHOW'\n      });\n    }\n    /**\n     * API: Hide a specific notification, given its ID\n     *\n     * @param {?} notificationId ID of the notification to hide\n     * @return {?}\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide(notificationId) {\n      this.queueService.push({\n        payload: notificationId,\n        type: 'HIDE'\n      });\n    }\n    /**\n     * API: Hide the newest notification\n     * @return {?}\n     */\n\n  }, {\n    key: \"hideNewest\",\n    value: function hideNewest() {\n      this.queueService.push({\n        type: 'HIDE_NEWEST'\n      });\n    }\n    /**\n     * API: Hide the oldest notification\n     * @return {?}\n     */\n\n  }, {\n    key: \"hideOldest\",\n    value: function hideOldest() {\n      this.queueService.push({\n        type: 'HIDE_OLDEST'\n      });\n    }\n    /**\n     * API: Hide all notifications at once\n     * @return {?}\n     */\n\n  }, {\n    key: \"hideAll\",\n    value: function hideAll() {\n      this.queueService.push({\n        type: 'HIDE_ALL'\n      });\n    }\n    /**\n     * API: Shortcut for showing a new notification\n     *\n     * @param {?} type             Type of the notification\n     * @param {?} message          Message of the notification\n     * @param {?=} notificationId\n     * @return {?}\n     */\n\n  }, {\n    key: \"notify\",\n    value: function notify(type, message, notificationId) {\n      /** @type {?} */\n      var notificationOptions = {\n        message: message,\n        type: type\n      };\n\n      if (notificationId !== undefined) {\n        notificationOptions.id = notificationId;\n      }\n\n      this.show(notificationOptions);\n    }\n  }]);\n\n  return NotifierService;\n}();\n\nNotifierService.ɵfac = function NotifierService_Factory(t) {\n  return new (t || NotifierService)(ɵngcc0.ɵɵinject(NotifierQueueService), ɵngcc0.ɵɵinject(NotifierConfigToken));\n};\n\nNotifierService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: NotifierService,\n  factory: NotifierService.ɵfac\n});\n/** @nocollapse */\n\nNotifierService.ctorParameters = function () {\n  return [{\n    type: NotifierQueueService\n  }, {\n    type: NotifierConfig,\n    decorators: [{\n      type: Inject,\n      args: [NotifierConfigToken]\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(NotifierService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: NotifierQueueService\n    }, {\n      type: NotifierConfig,\n      decorators: [{\n        type: Inject,\n        args: [NotifierConfigToken]\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * Notifier queue service\n   * @type {?}\n   * @private\n   */\n  NotifierService.prototype.queueService;\n  /**\n   * Notifier configuration\n   * @type {?}\n   * @private\n   */\n\n  NotifierService.prototype.config;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/components/notifier-container.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\n\n\nvar NotifierContainerComponent = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   *\n   * @param {?} changeDetector       Change detector, used for manually triggering change detection runs\n   * @param {?} notifierQueueService Notifier queue service\n   * @param {?} notifierService      Notifier service\n   */\n  function NotifierContainerComponent(changeDetector, notifierQueueService, notifierService) {\n    var _this = this;\n\n    _classCallCheck(this, NotifierContainerComponent);\n\n    this.changeDetector = changeDetector;\n    this.queueService = notifierQueueService;\n    this.config = notifierService.getConfig();\n    this.notifications = []; // Connects this component up to the action queue, then handle incoming actions\n\n    this.queueServiceSubscription = this.queueService.actionStream.subscribe(\n    /**\n    * @param {?} action\n    * @return {?}\n    */\n    function (action) {\n      _this.handleAction(action).then(\n      /**\n      * @return {?}\n      */\n      function () {\n        _this.queueService.continue();\n      });\n    });\n  }\n  /**\n   * Component destroyment lifecycle hook, cleans up the observable subsciption\n   * @return {?}\n   */\n\n\n  _createClass(NotifierContainerComponent, [{\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this.queueServiceSubscription) {\n        this.queueServiceSubscription.unsubscribe();\n      }\n    }\n    /**\n     * Notification identifier, used as the ngFor trackby function\n     *\n     * @param {?} index        Index\n     * @param {?} notification Notifier notification\n     * @return {?} Notification ID as the unique identnfier\n     */\n\n  }, {\n    key: \"identifyNotification\",\n    value: function identifyNotification(index, notification) {\n      return notification.id;\n    }\n    /**\n     * Event handler, handles clicks on notification dismiss buttons\n     *\n     * @param {?} notificationId ID of the notification to dismiss\n     * @return {?}\n     */\n\n  }, {\n    key: \"onNotificationDismiss\",\n    value: function onNotificationDismiss(notificationId) {\n      this.queueService.push({\n        payload: notificationId,\n        type: 'HIDE'\n      });\n    }\n    /**\n     * Event handler, handles notification ready events\n     *\n     * @param {?} notificationComponent Notification component reference\n     * @return {?}\n     */\n\n  }, {\n    key: \"onNotificationReady\",\n    value: function onNotificationReady(notificationComponent) {\n      /** @type {?} */\n      var currentNotification = this.notifications[this.notifications.length - 1];\n      currentNotification.component = notificationComponent; // Save the new omponent reference\n\n      this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n    }\n    /**\n     * Handle incoming actions by mapping action types to methods, and then running them\n     *\n     * @private\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"handleAction\",\n    value: function handleAction(action) {\n      switch (action.type // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n      ) {\n        case 'SHOW':\n          return this.handleShowAction(action);\n\n        case 'HIDE':\n          return this.handleHideAction(action);\n\n        case 'HIDE_OLDEST':\n          return this.handleHideOldestAction(action);\n\n        case 'HIDE_NEWEST':\n          return this.handleHideNewestAction(action);\n\n        case 'HIDE_ALL':\n          return this.handleHideAllAction();\n\n        default:\n          return new Promise(\n          /**\n          * @param {?} resolve\n          * @return {?}\n          */\n          function (resolve) {\n            resolve(); // Ignore unknown action types\n          });\n      }\n    }\n    /**\n     * Show a new notification\n     *\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n     *\n     * @private\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"handleShowAction\",\n    value: function handleShowAction(action) {\n      var _this2 = this;\n\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        _this2.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n\n        _this2.addNotificationToList(new NotifierNotification(action.payload));\n      });\n    }\n    /**\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\n     *\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n     *\n     * @private\n     * @param {?} notification New notification to show\n     * @return {?}\n     */\n\n  }, {\n    key: \"continueHandleShowAction\",\n    value: function continueHandleShowAction(notification) {\n      var _this3 = this;\n\n      // First (which means only one) notification in the list?\n\n      /** @type {?} */\n      var numberOfNotifications = this.notifications.length;\n\n      if (numberOfNotifications === 1) {\n        notification.component.show().then(this.tempPromiseResolver); // Done\n      } else {\n        /** @type {?} */\n        var implicitStackingLimit = 2; // Stacking enabled? (stacking value below 2 means stacking is disabled)\n\n        if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n          this.notifications[0].component.hide().then(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this3.removeNotificationFromList(_this3.notifications[0]);\n\n            notification.component.show().then(_this3.tempPromiseResolver); // Done\n          });\n        } else {\n          /** @type {?} */\n          var stepPromises = []; // Are there now too many notifications?\n\n          if (numberOfNotifications > this.config.behaviour.stacking) {\n            /** @type {?} */\n            var oldNotifications = this.notifications.slice(1, numberOfNotifications - 1); // Are animations enabled?\n\n            if (this.config.animations.enabled) {\n              // Is animation overlap enabled?\n              if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                stepPromises.push(this.notifications[0].component.hide());\n                setTimeout(\n                /**\n                * @return {?}\n                */\n                function () {\n                  stepPromises.push(_this3.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                }, this.config.animations.hide.speed - this.config.animations.overlap);\n                setTimeout(\n                /**\n                * @return {?}\n                */\n                function () {\n                  stepPromises.push(notification.component.show());\n                }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n              } else {\n                stepPromises.push(new Promise(\n                /**\n                * @param {?} resolve\n                * @return {?}\n                */\n                function (resolve) {\n                  _this3.notifications[0].component.hide().then(\n                  /**\n                  * @return {?}\n                  */\n                  function () {\n                    _this3.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(\n                    /**\n                    * @return {?}\n                    */\n                    function () {\n                      notification.component.show().then(resolve);\n                    });\n                  });\n                }));\n              }\n            } else {\n              stepPromises.push(this.notifications[0].component.hide());\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              stepPromises.push(notification.component.show());\n            }\n          } else {\n            /** @type {?} */\n            var _oldNotifications = this.notifications.slice(0, numberOfNotifications - 1); // Are animations enabled?\n\n\n            if (this.config.animations.enabled) {\n              // Is animation overlap enabled?\n              if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                stepPromises.push(this.shiftNotifications(_oldNotifications, notification.component.getHeight(), true));\n                setTimeout(\n                /**\n                * @return {?}\n                */\n                function () {\n                  stepPromises.push(notification.component.show());\n                }, this.config.animations.shift.speed - this.config.animations.overlap);\n              } else {\n                stepPromises.push(new Promise(\n                /**\n                * @param {?} resolve\n                * @return {?}\n                */\n                function (resolve) {\n                  _this3.shiftNotifications(_oldNotifications, notification.component.getHeight(), true).then(\n                  /**\n                  * @return {?}\n                  */\n                  function () {\n                    notification.component.show().then(resolve);\n                  });\n                }));\n              }\n            } else {\n              stepPromises.push(this.shiftNotifications(_oldNotifications, notification.component.getHeight(), true));\n              stepPromises.push(notification.component.show());\n            }\n          }\n\n          Promise.all(stepPromises).then(\n          /**\n          * @return {?}\n          */\n          function () {\n            if (numberOfNotifications > _this3.config.behaviour.stacking) {\n              _this3.removeNotificationFromList(_this3.notifications[0]);\n            }\n\n            _this3.tempPromiseResolver();\n          }); // Done\n        }\n      }\n    }\n    /**\n     * Hide an existing notification\n     *\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n     *\n     * @private\n     * @param {?} action Action object, payload contains the notification ID\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"handleHideAction\",\n    value: function handleHideAction(action) {\n      var _this4 = this;\n\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        /** @type {?} */\n        var stepPromises = []; // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n\n        /** @type {?} */\n\n        var notification = _this4.findNotificationById(action.payload);\n\n        if (notification === undefined) {\n          resolve();\n          return;\n        } // Get older notifications\n\n        /** @type {?} */\n\n\n        var notificationIndex = _this4.findNotificationIndexById(action.payload);\n\n        if (notificationIndex === undefined) {\n          resolve();\n          return;\n        }\n        /** @type {?} */\n\n\n        var oldNotifications = _this4.notifications.slice(0, notificationIndex); // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n\n\n        if (oldNotifications.length > 0) {\n          // Are animations enabled?\n          if (_this4.config.animations.enabled && _this4.config.animations.hide.speed > 0) {\n            // Is animation overlap enabled?\n            if (_this4.config.animations.overlap !== false && _this4.config.animations.overlap > 0) {\n              stepPromises.push(notification.component.hide());\n              setTimeout(\n              /**\n              * @return {?}\n              */\n              function () {\n                stepPromises.push(_this4.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n              }, _this4.config.animations.hide.speed - _this4.config.animations.overlap);\n            } else {\n              notification.component.hide().then(\n              /**\n              * @return {?}\n              */\n              function () {\n                stepPromises.push(_this4.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n              });\n            }\n          } else {\n            stepPromises.push(notification.component.hide());\n            stepPromises.push(_this4.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n          }\n        } else {\n          stepPromises.push(notification.component.hide());\n        } // Wait until both hiding and shifting is done, then remove the notification from the list\n\n\n        Promise.all(stepPromises).then(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this4.removeNotificationFromList(notification);\n\n          resolve(); // Done\n        });\n      });\n    }\n    /**\n     * Hide the oldest notification (bridge to handleHideAction)\n     *\n     * @private\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"handleHideOldestAction\",\n    value: function handleHideOldestAction(action) {\n      // Are there any notifications? (prevent accidential errors)\n      if (this.notifications.length === 0) {\n        return new Promise(\n        /**\n        * @param {?} resolve\n        * @return {?}\n        */\n        function (resolve) {\n          resolve();\n        }); // Done\n      } else {\n        action.payload = this.notifications[0].id;\n        return this.handleHideAction(action);\n      }\n    }\n    /**\n     * Hide the newest notification (bridge to handleHideAction)\n     *\n     * @private\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"handleHideNewestAction\",\n    value: function handleHideNewestAction(action) {\n      // Are there any notifications? (prevent accidential errors)\n      if (this.notifications.length === 0) {\n        return new Promise(\n        /**\n        * @param {?} resolve\n        * @return {?}\n        */\n        function (resolve) {\n          resolve();\n        }); // Done\n      } else {\n        action.payload = this.notifications[this.notifications.length - 1].id;\n        return this.handleHideAction(action);\n      }\n    }\n    /**\n     * Hide all notifications at once\n     *\n     * @private\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"handleHideAllAction\",\n    value: function handleHideAllAction() {\n      var _this5 = this;\n\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        // Are there any notifications? (prevent accidential errors)\n\n        /** @type {?} */\n        var numberOfNotifications = _this5.notifications.length;\n\n        if (numberOfNotifications === 0) {\n          resolve(); // Done\n\n          return;\n        } // Are animations enabled?\n\n\n        if (_this5.config.animations.enabled && _this5.config.animations.hide.speed > 0 && _this5.config.animations.hide.offset !== false && _this5.config.animations.hide.offset > 0) {\n          var _loop = function _loop(i) {\n            /** @type {?} */\n            var animationOffset = _this5.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n            setTimeout(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this5.notifications[i].component.hide().then(\n              /**\n              * @return {?}\n              */\n              function () {\n                // Are we done here, was this the last notification to be hidden?\n                if (_this5.config.position.vertical.position === 'top' && i === 0 || _this5.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1) {\n                  _this5.removeAllNotificationsFromList();\n\n                  resolve(); // Done\n                }\n              });\n            }, _this5.config.animations.hide.offset * animationOffset);\n          };\n\n          for (var i = numberOfNotifications - 1; i >= 0; i--) {\n            _loop(i);\n          }\n        } else {\n          /** @type {?} */\n          var stepPromises = [];\n\n          for (var _i = numberOfNotifications - 1; _i >= 0; _i--) {\n            stepPromises.push(_this5.notifications[_i].component.hide());\n          }\n\n          Promise.all(stepPromises).then(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this5.removeAllNotificationsFromList();\n\n            resolve(); // Done\n          });\n        }\n      });\n    }\n    /**\n     * Shift multiple notifications at once\n     *\n     * @private\n     * @param {?} notifications List containing the notifications to be shifted\n     * @param {?} distance      Distance to shift (in px)\n     * @param {?} toMakePlace   Flag, defining in which direciton to shift\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"shiftNotifications\",\n    value: function shiftNotifications(notifications, distance, toMakePlace) {\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        // Are there any notifications to shift?\n        if (notifications.length === 0) {\n          resolve();\n          return;\n        }\n        /** @type {?} */\n\n\n        var notificationPromises = [];\n\n        for (var i = notifications.length - 1; i >= 0; i--) {\n          notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n        }\n\n        Promise.all(notificationPromises).then(resolve); // Done\n      });\n    }\n    /**\n     * Add a new notification to the list of notifications (triggers change detection)\n     *\n     * @private\n     * @param {?} notification Notification to add to the list of notifications\n     * @return {?}\n     */\n\n  }, {\n    key: \"addNotificationToList\",\n    value: function addNotificationToList(notification) {\n      this.notifications.push(notification);\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove an existing notification from the list of notifications (triggers change detection)\n     *\n     * @private\n     * @param {?} notification Notification to be removed from the list of notifications\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeNotificationFromList\",\n    value: function removeNotificationFromList(notification) {\n      this.notifications = this.notifications.filter(\n      /**\n      * @param {?} item\n      * @return {?}\n      */\n      function (item) {\n        return item.component !== notification.component;\n      });\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove all notifications from the list (triggers change detection)\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeAllNotificationsFromList\",\n    value: function removeAllNotificationsFromList() {\n      this.notifications = [];\n      this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Helper: Find a notification in the notification list by a given notification ID\n     *\n     * @private\n     * @param {?} notificationId Notification ID, used for finding notification\n     * @return {?} Notification, undefined if not found\n     */\n\n  }, {\n    key: \"findNotificationById\",\n    value: function findNotificationById(notificationId) {\n      return this.notifications.find(\n      /**\n      * @param {?} currentNotification\n      * @return {?}\n      */\n      function (currentNotification) {\n        return currentNotification.id === notificationId;\n      });\n    }\n    /**\n     * Helper: Find a notification's index by a given notification ID\n     *\n     * @private\n     * @param {?} notificationId Notification ID, used for finding a notification's index\n     * @return {?} Notification index, undefined if not found\n     */\n\n  }, {\n    key: \"findNotificationIndexById\",\n    value: function findNotificationIndexById(notificationId) {\n      /** @type {?} */\n      var notificationIndex = this.notifications.findIndex(\n      /**\n      * @param {?} currentNotification\n      * @return {?}\n      */\n      function (currentNotification) {\n        return currentNotification.id === notificationId;\n      });\n      return notificationIndex !== -1 ? notificationIndex : undefined;\n    }\n  }]);\n\n  return NotifierContainerComponent;\n}();\n\nNotifierContainerComponent.ɵfac = function NotifierContainerComponent_Factory(t) {\n  return new (t || NotifierContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NotifierQueueService), ɵngcc0.ɵɵdirectiveInject(NotifierService));\n};\n\nNotifierContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: NotifierContainerComponent,\n  selectors: [[\"notifier-container\"]],\n  hostAttrs: [1, \"notifier__container\"],\n  decls: 2,\n  vars: 2,\n  consts: [[\"class\", \"notifier__container-list\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"notifier__container-list\"], [3, \"notification\", \"ready\", \"dismiss\"]],\n  template: function NotifierContainerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementStart(0, \"ul\");\n      ɵngcc0.ɵɵtemplate(1, NotifierContainerComponent_li_1_Template, 2, 1, \"li\", 0);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.notifications)(\"ngForTrackBy\", ctx.identifyNotification);\n    }\n  },\n  directives: function directives() {\n    return [ɵngcc1.NgForOf, NotifierNotificationComponent];\n  },\n  encapsulation: 2,\n  changeDetection: 0\n});\n/** @nocollapse */\n\nNotifierContainerComponent.ctorParameters = function () {\n  return [{\n    type: ChangeDetectorRef\n  }, {\n    type: NotifierQueueService\n  }, {\n    type: NotifierService\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(NotifierContainerComponent, [{\n    type: Component,\n    args: [{\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      // (#perfmatters)\n      host: {\n        class: 'notifier__container'\n      },\n      selector: 'notifier-container',\n      template: \"<ul>\\n  <li class=\\\"notifier__container-list\\\" *ngFor=\\\"let notification of notifications; trackBy: identifyNotification\\\">\\n    <notifier-notification [notification]=\\\"notification\\\" (ready)=\\\"onNotificationReady($event)\\\" (dismiss)=\\\"onNotificationDismiss($event)\\\">\\n    </notifier-notification>\\n  </li>\\n</ul>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ChangeDetectorRef\n    }, {\n      type: NotifierQueueService\n    }, {\n      type: NotifierService\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * List of currently somewhat active notifications\n   * @type {?}\n   */\n  NotifierContainerComponent.prototype.notifications;\n  /**\n   * Change detector\n   * @type {?}\n   * @private\n   */\n\n  NotifierContainerComponent.prototype.changeDetector;\n  /**\n   * Notifier queue service\n   * @type {?}\n   * @private\n   */\n\n  NotifierContainerComponent.prototype.queueService;\n  /**\n   * Notifier configuration\n   * @type {?}\n   * @private\n   */\n\n  NotifierContainerComponent.prototype.config;\n  /**\n   * Queue service observable subscription (saved for cleanup)\n   * @type {?}\n   * @private\n   */\n\n  NotifierContainerComponent.prototype.queueServiceSubscription;\n  /**\n   * Promise resolve function reference, temporarily used while the notification child component gets created\n   * @type {?}\n   * @private\n   */\n\n  NotifierContainerComponent.prototype.tempPromiseResolver;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/animation-presets/fade.animation-preset.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar ɵ0 =\n/**\n* @return {?}\n*/\nfunction ɵ0() {\n  return {\n    from: {\n      opacity: '1'\n    },\n    to: {\n      opacity: '0'\n    }\n  };\n},\n    ɵ1 =\n/**\n* @return {?}\n*/\nfunction ɵ1() {\n  return {\n    from: {\n      opacity: '0'\n    },\n    to: {\n      opacity: '1'\n    }\n  };\n};\n/**\n * Fade animation preset\n * @type {?}\n */\n\n\nvar fade = {\n  hide: ɵ0,\n  show: ɵ1\n};\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/animation-presets/slide.animation-preset.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nvar ɵ0$1 =\n/**\n* @param {?} notification\n* @return {?}\n*/\nfunction ɵ0$1(notification) {\n  // Prepare variables\n\n  /** @type {?} */\n  var config = notification.component.getConfig();\n  /** @type {?} */\n\n  var shift = notification.component.getShift();\n  /** @type {?} */\n\n  var from;\n  /** @type {?} */\n\n  var to; // Configure variables, depending on configuration and component\n\n  if (config.position.horizontal.position === 'left') {\n    from = {\n      transform: \"translate3d( 0, \".concat(shift, \"px, 0 )\")\n    };\n    to = {\n      transform: \"translate3d( calc( -100% - \".concat(config.position.horizontal.distance, \"px - 10px ), \").concat(shift, \"px, 0 )\")\n    };\n  } else if (config.position.horizontal.position === 'right') {\n    from = {\n      transform: \"translate3d( 0, \".concat(shift, \"px, 0 )\")\n    };\n    to = {\n      transform: \"translate3d( calc( 100% + \".concat(config.position.horizontal.distance, \"px + 10px ), \").concat(shift, \"px, 0 )\")\n    };\n  } else {\n    /** @type {?} */\n    var horizontalPosition;\n\n    if (config.position.vertical.position === 'top') {\n      horizontalPosition = \"calc( -100% - \".concat(config.position.horizontal.distance, \"px - 10px )\");\n    } else {\n      horizontalPosition = \"calc( 100% + \".concat(config.position.horizontal.distance, \"px + 10px )\");\n    }\n\n    from = {\n      transform: \"translate3d( -50%, \".concat(shift, \"px, 0 )\")\n    };\n    to = {\n      transform: \"translate3d( -50%, \".concat(horizontalPosition, \", 0 )\")\n    };\n  } // Done\n\n\n  return {\n    from: from,\n    to: to\n  };\n},\n    ɵ1$1 =\n/**\n* @param {?} notification\n* @return {?}\n*/\nfunction ɵ1$1(notification) {\n  // Prepare variables\n\n  /** @type {?} */\n  var config = notification.component.getConfig();\n  /** @type {?} */\n\n  var from;\n  /** @type {?} */\n\n  var to; // Configure variables, depending on configuration and component\n\n  if (config.position.horizontal.position === 'left') {\n    from = {\n      transform: \"translate3d( calc( -100% - \".concat(config.position.horizontal.distance, \"px - 10px ), 0, 0 )\")\n    };\n    to = {\n      transform: 'translate3d( 0, 0, 0 )'\n    };\n  } else if (config.position.horizontal.position === 'right') {\n    from = {\n      transform: \"translate3d( calc( 100% + \".concat(config.position.horizontal.distance, \"px + 10px ), 0, 0 )\")\n    };\n    to = {\n      transform: 'translate3d( 0, 0, 0 )'\n    };\n  } else {\n    /** @type {?} */\n    var horizontalPosition;\n\n    if (config.position.vertical.position === 'top') {\n      horizontalPosition = \"calc( -100% - \".concat(config.position.horizontal.distance, \"px - 10px )\");\n    } else {\n      horizontalPosition = \"calc( 100% + \".concat(config.position.horizontal.distance, \"px + 10px )\");\n    }\n\n    from = {\n      transform: \"translate3d( -50%, \".concat(horizontalPosition, \", 0 )\")\n    };\n    to = {\n      transform: 'translate3d( -50%, 0, 0 )'\n    };\n  } // Done\n\n\n  return {\n    from: from,\n    to: to\n  };\n};\n/**\n * Slide animation preset\n * @type {?}\n */\n\n\nvar slide = {\n  hide: ɵ0$1,\n  show: ɵ1$1\n};\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/services/notifier-animation.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Notifier animation service\n */\n\nvar NotifierAnimationService = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   */\n  function NotifierAnimationService() {\n    _classCallCheck(this, NotifierAnimationService);\n\n    this.animationPresets = {\n      fade: fade,\n      slide: slide\n    };\n  }\n  /**\n   * Get animation data\n   *\n   * This method generates all data the Web Animations API needs to animate our notification. The result depends on both the animation\n   * direction (either in or out) as well as the notifications (and its attributes) itself.\n   *\n   * @param {?} direction    Animation direction, either in or out\n   * @param {?} notification Notification the animation data should be generated for\n   * @return {?} Animation information\n   */\n\n\n  _createClass(NotifierAnimationService, [{\n    key: \"getAnimationData\",\n    value: function getAnimationData(direction, notification) {\n      // Get all necessary animation data\n\n      /** @type {?} */\n      var keyframes;\n      /** @type {?} */\n\n      var duration;\n      /** @type {?} */\n\n      var easing;\n\n      if (direction === 'show') {\n        keyframes = this.animationPresets[notification.component.getConfig().animations.show.preset].show(notification);\n        duration = notification.component.getConfig().animations.show.speed;\n        easing = notification.component.getConfig().animations.show.easing;\n      } else {\n        keyframes = this.animationPresets[notification.component.getConfig().animations.hide.preset].hide(notification);\n        duration = notification.component.getConfig().animations.hide.speed;\n        easing = notification.component.getConfig().animations.hide.easing;\n      } // Build and return animation data\n\n\n      return {\n        keyframes: [keyframes.from, keyframes.to],\n        options: {\n          duration: duration,\n          easing: easing,\n          fill: 'forwards'\n        }\n      };\n    }\n  }]);\n\n  return NotifierAnimationService;\n}();\n\nNotifierAnimationService.ɵfac = function NotifierAnimationService_Factory(t) {\n  return new (t || NotifierAnimationService)();\n};\n\nNotifierAnimationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: NotifierAnimationService,\n  factory: NotifierAnimationService.ɵfac\n});\n/** @nocollapse */\n\nNotifierAnimationService.ctorParameters = function () {\n  return [];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(NotifierAnimationService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * List of animation presets (currently static)\n   * @type {?}\n   * @private\n   */\n  NotifierAnimationService.prototype.animationPresets;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/services/notifier-timer.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\n\n\nvar NotifierTimerService = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   */\n  function NotifierTimerService() {\n    _classCallCheck(this, NotifierTimerService);\n\n    this.now = 0;\n    this.remaining = 0;\n  }\n  /**\n   * Start (or resume) the timer\n   *\n   * @param {?} duration Timer duration, in ms\n   * @return {?} Promise, resolved once the timer finishes\n   */\n\n\n  _createClass(NotifierTimerService, [{\n    key: \"start\",\n    value: function start(duration) {\n      var _this6 = this;\n\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        // For the first run ...\n        _this6.remaining = duration; // Setup, then start the timer\n\n        _this6.finishPromiseResolver = resolve;\n\n        _this6.continue();\n      });\n    }\n    /**\n     * Pause the timer\n     * @return {?}\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      clearTimeout(this.timerId);\n      this.remaining -= new Date().getTime() - this.now;\n    }\n    /**\n     * Continue the timer\n     * @return {?}\n     */\n\n  }, {\n    key: \"continue\",\n    value: function _continue() {\n      var _this7 = this;\n\n      this.now = new Date().getTime();\n      this.timerId = window.setTimeout(\n      /**\n      * @return {?}\n      */\n      function () {\n        _this7.finish();\n      }, this.remaining);\n    }\n    /**\n     * Stop the timer\n     * @return {?}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearTimeout(this.timerId);\n      this.remaining = 0;\n    }\n    /**\n     * Finish up the timeout by resolving the timer promise\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.finishPromiseResolver();\n    }\n  }]);\n\n  return NotifierTimerService;\n}();\n\nNotifierTimerService.ɵfac = function NotifierTimerService_Factory(t) {\n  return new (t || NotifierTimerService)();\n};\n\nNotifierTimerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: NotifierTimerService,\n  factory: NotifierTimerService.ɵfac\n});\n/** @nocollapse */\n\nNotifierTimerService.ctorParameters = function () {\n  return [];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(NotifierTimerService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * Timestamp (in ms), created in the moment the timer starts\n   * @type {?}\n   * @private\n   */\n  NotifierTimerService.prototype.now;\n  /**\n   * Remaining time (in ms)\n   * @type {?}\n   * @private\n   */\n\n  NotifierTimerService.prototype.remaining;\n  /**\n   * Timeout ID, used for clearing the timeout later on\n   * @type {?}\n   * @private\n   */\n\n  NotifierTimerService.prototype.timerId;\n  /**\n   * Promise resolve function, eventually getting called once the timer finishes\n   * @type {?}\n   * @private\n   */\n\n  NotifierTimerService.prototype.finishPromiseResolver;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/components/notifier-notification.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\n\n\nvar NotifierNotificationComponent = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   *\n   * @param {?} elementRef               Reference to the component's element\n   * @param {?} renderer                 Angular renderer\n   * @param {?} notifierService          Notifier service\n   * @param {?} notifierTimerService     Notifier timer service\n   * @param {?} notifierAnimationService Notifier animation service\n   */\n  function NotifierNotificationComponent(elementRef, renderer, notifierService, notifierTimerService, notifierAnimationService) {\n    _classCallCheck(this, NotifierNotificationComponent);\n\n    this.config = notifierService.getConfig();\n    this.ready = new EventEmitter();\n    this.dismiss = new EventEmitter();\n    this.timerService = notifierTimerService;\n    this.animationService = notifierAnimationService;\n    this.renderer = renderer;\n    this.element = elementRef.nativeElement;\n    this.elementShift = 0;\n  }\n  /**\n   * Component after view init lifecycle hook, setts up the component and then emits the ready event\n   * @return {?}\n   */\n\n\n  _createClass(NotifierNotificationComponent, [{\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      this.setup();\n      this.elementHeight = this.element.offsetHeight;\n      this.elementWidth = this.element.offsetWidth;\n      this.ready.emit(this);\n    }\n    /**\n     * Get the notifier config\n     *\n     * @return {?} Notifier configuration\n     */\n\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.config;\n    }\n    /**\n     * Get notification element height (in px)\n     *\n     * @return {?} Notification element height (in px)\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return this.elementHeight;\n    }\n    /**\n     * Get notification element width (in px)\n     *\n     * @return {?} Notification element height (in px)\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return this.elementWidth;\n    }\n    /**\n     * Get notification shift offset (in px)\n     *\n     * @return {?} Notification element shift offset (in px)\n     */\n\n  }, {\n    key: \"getShift\",\n    value: function getShift() {\n      return this.elementShift;\n    }\n    /**\n     * Show (animate in) this notification\n     *\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      var _this8 = this;\n\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        // Are animations enabled?\n        if (_this8.config.animations.enabled && _this8.config.animations.show.speed > 0) {\n          // Get animation data\n\n          /** @type {?} */\n          var animationData = _this8.animationService.getAnimationData('show', _this8.notification); // Set initial styles (styles before animation), prevents quick flicker when animation starts\n\n          /** @type {?} */\n\n\n          var animatedProperties = Object.keys(animationData.keyframes[0]);\n\n          for (var i = animatedProperties.length - 1; i >= 0; i--) {\n            _this8.renderer.setStyle(_this8.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n          } // Animate notification in\n\n\n          _this8.renderer.setStyle(_this8.element, 'visibility', 'visible');\n          /** @type {?} */\n\n\n          var animation = _this8.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish =\n          /**\n          * @return {?}\n          */\n          function () {\n            _this8.startAutoHideTimer();\n\n            resolve(); // Done\n          };\n        } else {\n          // Show notification\n          _this8.renderer.setStyle(_this8.element, 'visibility', 'visible');\n\n          _this8.startAutoHideTimer();\n\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Hide (animate out) this notification\n     *\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this9 = this;\n\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        _this9.stopAutoHideTimer(); // Are animations enabled?\n\n\n        if (_this9.config.animations.enabled && _this9.config.animations.hide.speed > 0) {\n          /** @type {?} */\n          var animationData = _this9.animationService.getAnimationData('hide', _this9.notification);\n          /** @type {?} */\n\n\n          var animation = _this9.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish =\n          /**\n          * @return {?}\n          */\n          function () {\n            resolve(); // Done\n          };\n        } else {\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Shift (move) this notification\n     *\n     * @param {?} distance         Distance to shift (in px)\n     * @param {?} shiftToMakePlace Flag, defining in which direction to shift\n     * @return {?} Promise, resolved when done\n     */\n\n  }, {\n    key: \"shift\",\n    value: function shift(distance, shiftToMakePlace) {\n      var _this10 = this;\n\n      return new Promise(\n      /**\n      * @param {?} resolve\n      * @return {?}\n      */\n      function (resolve) {\n        // Calculate new position (position after the shift)\n\n        /** @type {?} */\n        var newElementShift;\n\n        if (_this10.config.position.vertical.position === 'top' && shiftToMakePlace || _this10.config.position.vertical.position === 'bottom' && !shiftToMakePlace) {\n          newElementShift = _this10.elementShift + distance + _this10.config.position.vertical.gap;\n        } else {\n          newElementShift = _this10.elementShift - distance - _this10.config.position.vertical.gap;\n        }\n        /** @type {?} */\n\n\n        var horizontalPosition = _this10.config.position.horizontal.position === 'middle' ? '-50%' : '0'; // Are animations enabled?\n\n        if (_this10.config.animations.enabled && _this10.config.animations.shift.speed > 0) {\n          /** @type {?} */\n          var animationData = {\n            // TODO: Extract into animation service\n            keyframes: [{\n              transform: \"translate3d( \".concat(horizontalPosition, \", \").concat(_this10.elementShift, \"px, 0 )\")\n            }, {\n              transform: \"translate3d( \".concat(horizontalPosition, \", \").concat(newElementShift, \"px, 0 )\")\n            }],\n            options: {\n              duration: _this10.config.animations.shift.speed,\n              easing: _this10.config.animations.shift.easing,\n              fill: 'forwards'\n            }\n          };\n          _this10.elementShift = newElementShift;\n          /** @type {?} */\n\n          var animation = _this10.element.animate(animationData.keyframes, animationData.options);\n\n          animation.onfinish =\n          /**\n          * @return {?}\n          */\n          function () {\n            resolve(); // Done\n          };\n        } else {\n          _this10.renderer.setStyle(_this10.element, 'transform', \"translate3d( \".concat(horizontalPosition, \", \").concat(newElementShift, \"px, 0 )\"));\n\n          _this10.elementShift = newElementShift;\n          resolve(); // Done\n        }\n      });\n    }\n    /**\n     * Handle click on dismiss button\n     * @return {?}\n     */\n\n  }, {\n    key: \"onClickDismiss\",\n    value: function onClickDismiss() {\n      this.dismiss.emit(this.notification.id);\n    }\n    /**\n     * Handle mouseover over notification area\n     * @return {?}\n     */\n\n  }, {\n    key: \"onNotificationMouseover\",\n    value: function onNotificationMouseover() {\n      if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n        this.pauseAutoHideTimer();\n      } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n        this.stopAutoHideTimer();\n      }\n    }\n    /**\n     * Handle mouseout from notification area\n     * @return {?}\n     */\n\n  }, {\n    key: \"onNotificationMouseout\",\n    value: function onNotificationMouseout() {\n      if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n        this.continueAutoHideTimer();\n      } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n        this.startAutoHideTimer();\n      }\n    }\n    /**\n     * Handle click on notification area\n     * @return {?}\n     */\n\n  }, {\n    key: \"onNotificationClick\",\n    value: function onNotificationClick() {\n      if (this.config.behaviour.onClick === 'hide') {\n        this.onClickDismiss();\n      }\n    }\n    /**\n     * Start the auto hide timer (if enabled)\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"startAutoHideTimer\",\n    value: function startAutoHideTimer() {\n      var _this11 = this;\n\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.start(this.config.behaviour.autoHide).then(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this11.onClickDismiss();\n        });\n      }\n    }\n    /**\n     * Pause the auto hide timer (if enabled)\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"pauseAutoHideTimer\",\n    value: function pauseAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.pause();\n      }\n    }\n    /**\n     * Continue the auto hide timer (if enabled)\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"continueAutoHideTimer\",\n    value: function continueAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.continue();\n      }\n    }\n    /**\n     * Stop the auto hide timer (if enabled)\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"stopAutoHideTimer\",\n    value: function stopAutoHideTimer() {\n      if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n        this.timerService.stop();\n      }\n    }\n    /**\n     * Initial notification setup\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      // Set start position (initially the exact same for every new notification)\n      if (this.config.position.horizontal.position === 'left') {\n        this.renderer.setStyle(this.element, 'left', \"\".concat(this.config.position.horizontal.distance, \"px\"));\n      } else if (this.config.position.horizontal.position === 'right') {\n        this.renderer.setStyle(this.element, 'right', \"\".concat(this.config.position.horizontal.distance, \"px\"));\n      } else {\n        this.renderer.setStyle(this.element, 'left', '50%'); // Let's get the GPU handle some work as well (#perfmatters)\n\n        this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n      }\n\n      if (this.config.position.vertical.position === 'top') {\n        this.renderer.setStyle(this.element, 'top', \"\".concat(this.config.position.vertical.distance, \"px\"));\n      } else {\n        this.renderer.setStyle(this.element, 'bottom', \"\".concat(this.config.position.vertical.distance, \"px\"));\n      } // Add classes (responsible for visual design)\n\n\n      this.renderer.addClass(this.element, \"notifier__notification--\".concat(this.notification.type));\n      this.renderer.addClass(this.element, \"notifier__notification--\".concat(this.config.theme));\n    }\n  }]);\n\n  return NotifierNotificationComponent;\n}();\n\nNotifierNotificationComponent.ɵfac = function NotifierNotificationComponent_Factory(t) {\n  return new (t || NotifierNotificationComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NotifierService), ɵngcc0.ɵɵdirectiveInject(NotifierTimerService), ɵngcc0.ɵɵdirectiveInject(NotifierAnimationService));\n};\n\nNotifierNotificationComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: NotifierNotificationComponent,\n  selectors: [[\"notifier-notification\"]],\n  hostAttrs: [1, \"notifier__notification\"],\n  hostBindings: function NotifierNotificationComponent_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"click\", function NotifierNotificationComponent_click_HostBindingHandler() {\n        return ctx.onNotificationClick();\n      })(\"mouseout\", function NotifierNotificationComponent_mouseout_HostBindingHandler() {\n        return ctx.onNotificationMouseout();\n      })(\"mouseover\", function NotifierNotificationComponent_mouseover_HostBindingHandler() {\n        return ctx.onNotificationMouseover();\n      });\n    }\n  },\n  inputs: {\n    notification: \"notification\"\n  },\n  outputs: {\n    ready: \"ready\",\n    dismiss: \"dismiss\"\n  },\n  features: [ɵngcc0.ɵɵProvidersFeature([// We provide the timer to the component's local injector, so that every notification components gets its own\n  // instance of the timer service, thus running their timers independently from each other\n  NotifierTimerService])],\n  decls: 3,\n  vars: 2,\n  consts: [[3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\", \"ngIfElse\"], [\"predefinedNotification\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"notifier__notification-message\"], [\"class\", \"notifier__notification-button\", \"type\", \"button\", \"title\", \"dismiss\", 3, \"click\", 4, \"ngIf\"], [\"type\", \"button\", \"title\", \"dismiss\", 1, \"notifier__notification-button\", 3, \"click\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"20\", \"height\", \"20\", 1, \"notifier__notification-button-icon\"], [\"d\", \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"]],\n  template: function NotifierNotificationComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵtemplate(0, NotifierNotificationComponent_ng_container_0_Template, 1, 4, \"ng-container\", 0);\n      ɵngcc0.ɵɵtemplate(1, NotifierNotificationComponent_ng_template_1_Template, 3, 2, \"ng-template\", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);\n    }\n\n    if (rf & 2) {\n      var _r1 = ɵngcc0.ɵɵreference(2);\n\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.notification.template)(\"ngIfElse\", _r1);\n    }\n  },\n  directives: [ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet],\n  encapsulation: 2,\n  changeDetection: 0\n});\n/** @nocollapse */\n\nNotifierNotificationComponent.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: NotifierService\n  }, {\n    type: NotifierTimerService\n  }, {\n    type: NotifierAnimationService\n  }];\n};\n\nNotifierNotificationComponent.propDecorators = {\n  notification: [{\n    type: Input\n  }],\n  ready: [{\n    type: Output\n  }],\n  dismiss: [{\n    type: Output\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(NotifierNotificationComponent, [{\n    type: Component,\n    args: [{\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      // (#perfmatters)\n      host: {\n        '(click)': 'onNotificationClick()',\n        '(mouseout)': 'onNotificationMouseout()',\n        '(mouseover)': 'onNotificationMouseover()',\n        class: 'notifier__notification'\n      },\n      providers: [// We provide the timer to the component's local injector, so that every notification components gets its own\n      // instance of the timer service, thus running their timers independently from each other\n      NotifierTimerService],\n      selector: 'notifier-notification',\n      template: \"<ng-container\\n  *ngIf=\\\"notification.template; else predefinedNotification\\\"\\n  [ngTemplateOutlet]=\\\"notification.template\\\"\\n  [ngTemplateOutletContext]=\\\"{ notification: notification }\\\"\\n>\\n</ng-container>\\n\\n<ng-template #predefinedNotification>\\n  <p class=\\\"notifier__notification-message\\\">{{ notification.message }}</p>\\n  <button\\n    class=\\\"notifier__notification-button\\\"\\n    type=\\\"button\\\"\\n    title=\\\"dismiss\\\"\\n    *ngIf=\\\"config.behaviour.showDismissButton\\\"\\n    (click)=\\\"onClickDismiss()\\\"\\n  >\\n    <svg class=\\\"notifier__notification-button-icon\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"20\\\" height=\\\"20\\\">\\n      <path d=\\\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\\\" />\\n    </svg>\\n  </button>\\n</ng-template>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: NotifierService\n    }, {\n      type: NotifierTimerService\n    }, {\n      type: NotifierAnimationService\n    }];\n  }, {\n    ready: [{\n      type: Output\n    }],\n    dismiss: [{\n      type: Output\n    }],\n    notification: [{\n      type: Input\n    }]\n  });\n})();\n\nif (false) {\n  /**\n   * Input: Notification object, contains all details necessary to construct the notification\n   * @type {?}\n   */\n  NotifierNotificationComponent.prototype.notification;\n  /**\n   * Output: Ready event, handles the initialization success by emitting a reference to this notification component\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.ready;\n  /**\n   * Output: Dismiss event, handles the click on the dismiss button by emitting the notification ID of this notification component\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.dismiss;\n  /**\n   * Notifier configuration\n   * @type {?}\n   */\n\n  NotifierNotificationComponent.prototype.config;\n  /**\n   * Notifier timer service\n   * @type {?}\n   * @private\n   */\n\n  NotifierNotificationComponent.prototype.timerService;\n  /**\n   * Notifier animation service\n   * @type {?}\n   * @private\n   */\n\n  NotifierNotificationComponent.prototype.animationService;\n  /**\n   * Angular renderer, used to preserve the overall DOM abstraction & independence\n   * @type {?}\n   * @private\n   */\n\n  NotifierNotificationComponent.prototype.renderer;\n  /**\n   * Native element reference, used for manipulating DOM properties\n   * @type {?}\n   * @private\n   */\n\n  NotifierNotificationComponent.prototype.element;\n  /**\n   * Current notification height, calculated and cached here (#perfmatters)\n   * @type {?}\n   * @private\n   */\n\n  NotifierNotificationComponent.prototype.elementHeight;\n  /**\n   * Current notification width, calculated and cached here (#perfmatters)\n   * @type {?}\n   * @private\n   */\n\n  NotifierNotificationComponent.prototype.elementWidth;\n  /**\n   * Current notification shift, calculated and cached here (#perfmatters)\n   * @type {?}\n   * @private\n   */\n\n  NotifierNotificationComponent.prototype.elementShift;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/notifier.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Factory for a notifier configuration with custom options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @param {?} options - Custom notifier options\n * @return {?} - Notifier configuration as result\n */\n\n\nfunction notifierCustomConfigFactory(options) {\n  return new NotifierConfig(options);\n}\n/**\n * Factory for a notifier configuration with default options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @return {?} - Notifier configuration as result\n */\n\n\nfunction notifierDefaultConfigFactory() {\n  return new NotifierConfig({});\n}\n/**\n * Notifier module\n */\n\n\nvar NotifierModule = /*#__PURE__*/function () {\n  function NotifierModule() {\n    _classCallCheck(this, NotifierModule);\n  }\n\n  _createClass(NotifierModule, null, [{\n    key: \"withConfig\",\n    value:\n    /**\n     * Setup the notifier module with custom providers, in this case with a custom configuration based on the givne options\n     *\n     * @param {?=} options\n     * @return {?} - Notifier module with custom providers\n     */\n    function withConfig() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        ngModule: NotifierModule,\n        providers: [// Provide the options itself upfront (as we need to inject them as dependencies -- see below)\n        {\n          provide: NotifierOptionsToken,\n          useValue: options\n        }, // Provide a custom notifier configuration, based on the given notifier options\n        {\n          deps: [NotifierOptionsToken],\n          provide: NotifierConfigToken,\n          useFactory: notifierCustomConfigFactory\n        }]\n      };\n    }\n  }]);\n\n  return NotifierModule;\n}();\n\nNotifierModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: NotifierModule\n});\nNotifierModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function NotifierModule_Factory(t) {\n    return new (t || NotifierModule)();\n  },\n  providers: [NotifierAnimationService, NotifierService, NotifierQueueService, // Provide the default notifier configuration if just the module is imported\n  {\n    provide: NotifierConfigToken,\n    useFactory: notifierDefaultConfigFactory\n  }],\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NotifierModule, {\n    declarations: function declarations() {\n      return [NotifierContainerComponent, NotifierNotificationComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [NotifierContainerComponent];\n    }\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(NotifierModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NotifierContainerComponent, NotifierNotificationComponent],\n      exports: [NotifierContainerComponent],\n      imports: [CommonModule],\n      providers: [NotifierAnimationService, NotifierService, NotifierQueueService, // Provide the default notifier configuration if just the module is imported\n      {\n        provide: NotifierConfigToken,\n        useFactory: notifierDefaultConfigFactory\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-notifier.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { NotifierConfig, NotifierConfigToken, NotifierContainerComponent, NotifierModule, NotifierNotificationComponent, NotifierOptionsToken, NotifierService, notifierCustomConfigFactory, notifierDefaultConfigFactory, NotifierQueueService as ɵa, NotifierTimerService as ɵb, NotifierAnimationService as ɵc };","map":{"version":3,"sources":["angular-notifier/lib/models/notifier-notification.model.ts","angular-notifier/lib/models/notifier-config.model.ts","angular-notifier/lib/notifier.tokens.ts","angular-notifier/lib/services/notifier-queue.service.ts","angular-notifier/lib/services/notifier.service.ts","angular-notifier/lib/components/notifier-container.component.ts","angular-notifier/lib/animation-presets/fade.animation-preset.ts","angular-notifier/lib/animation-presets/slide.animation-preset.ts","angular-notifier/lib/services/notifier-animation.service.ts","angular-notifier/lib/services/notifier-timer.service.ts","angular-notifier/lib/components/notifier-notification.component.ts","angular-notifier/lib/notifier.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { TemplateRef } from '@angular/core';\n\nimport { NotifierNotificationComponent } from '../components/notifier-notification.component';\n\n/**\n * Notification\n *\n * This class describes the structure of a notifiction, including all information it needs to live, and everyone else needs to work with it.\n */\nexport class NotifierNotification {\n  /**\n   * Unique notification ID, can be set manually to control the notification from outside later on\n   */\n  public id: string;\n\n  /**\n   * Notification type, will be used for constructing an appropriate class name\n   */\n  public type: string;\n\n  /**\n   * Notification message\n   */\n  public message: string;\n\n  /**\n   * The template to customize\n   * the appearance of the notification\n   */\n  public template?: TemplateRef<any> = null;\n\n  /**\n   * Component reference of this notification, created and set during creation time\n   */\n  public component: NotifierNotificationComponent;\n\n  /**\n   * Constructor\n   *\n   * @param options Notifier options\n   */\n  public constructor(options: NotifierNotificationOptions) {\n    Object.assign(this, options);\n\n    // If not set manually, we have to create a unique notification ID by ourselves. The ID generation relies on the current browser\n    // datetime in ms, in praticular the moment this notification gets constructed. Concurrency, and thus two IDs being the exact same,\n    // is not possible due to the action queue concept.\n    if (options.id === undefined) {\n      this.id = `ID_${new Date().getTime()}`;\n    }\n  }\n}\n\n/**\n * Notifiction options\n *\n * This interface describes which information are needed to create a new notification, or in other words, which information the external API\n * call must provide.\n */\nexport interface NotifierNotificationOptions {\n  /**\n   * Notification ID, optional\n   */\n  id?: string;\n\n  /**\n   * Notification type\n   */\n  type: string;\n\n  /**\n   * Notificatin message\n   */\n  message: string;\n\n  /**\n   * The template to customize\n   * the appearance of the notification\n   */\n  template?: TemplateRef<any>;\n}\n","/**\n * Notifier options\n */\nexport interface NotifierOptions {\n  animations?: {\n    enabled?: boolean;\n    hide?: {\n      easing?: string;\n      offset?: number | false;\n      preset?: string;\n      speed?: number;\n    };\n    overlap?: number | false;\n    shift?: {\n      easing?: string;\n      speed?: number;\n    };\n    show?: {\n      easing?: string;\n      preset?: string;\n      speed?: number;\n    };\n  };\n  behaviour?: {\n    autoHide?: number | false;\n    onClick?: 'hide' | false;\n    onMouseover?: 'pauseAutoHide' | 'resetAutoHide' | false;\n    showDismissButton?: boolean;\n    stacking?: number | false;\n  };\n  position?: {\n    horizontal?: {\n      distance?: number;\n      position?: 'left' | 'middle' | 'right';\n    };\n    vertical?: {\n      distance?: number;\n      gap?: number;\n      position?: 'top' | 'bottom';\n    };\n  };\n  theme?: string;\n}\n\n/**\n * Notifier configuration\n *\n * The notifier configuration defines what notifications look like, how they behave, and how they get animated. It is a global\n * configuration, which means that it only can be set once (at the beginning), and cannot be changed afterwards. Aligning to the world of\n * Angular, this configuration can be provided in the root app module - alternatively, a meaningful default configuration will be used.\n */\nexport class NotifierConfig implements NotifierOptions {\n  /**\n   * Customize animations\n   */\n  public animations: {\n    enabled: boolean;\n    hide: {\n      easing: string;\n      offset: number | false;\n      preset: string;\n      speed: number;\n    };\n    overlap: number | false;\n    shift: {\n      easing: string;\n      speed: number;\n    };\n    show: {\n      easing: string;\n      preset: string;\n      speed: number;\n    };\n  };\n\n  /**\n   * Customize behaviour\n   */\n  public behaviour: {\n    autoHide: number | false;\n    onClick: 'hide' | false;\n    onMouseover: 'pauseAutoHide' | 'resetAutoHide' | false;\n    showDismissButton: boolean;\n    stacking: number | false;\n  };\n\n  /**\n   * Customize positioning\n   */\n  public position: {\n    horizontal: {\n      distance: number;\n      position: 'left' | 'middle' | 'right';\n    };\n    vertical: {\n      distance: number;\n      gap: number;\n      position: 'top' | 'bottom';\n    };\n  };\n\n  /**\n   * Customize theming\n   */\n  public theme: string;\n\n  /**\n   * Constructor\n   *\n   * @param [customOptions={}] Custom notifier options, optional\n   */\n  public constructor(customOptions: NotifierOptions = {}) {\n    // Set default values\n    this.animations = {\n      enabled: true,\n      hide: {\n        easing: 'ease',\n        offset: 50,\n        preset: 'fade',\n        speed: 300,\n      },\n      overlap: 150,\n      shift: {\n        easing: 'ease',\n        speed: 300,\n      },\n      show: {\n        easing: 'ease',\n        preset: 'slide',\n        speed: 300,\n      },\n    };\n    this.behaviour = {\n      autoHide: 7000,\n      onClick: false,\n      onMouseover: 'pauseAutoHide',\n      showDismissButton: true,\n      stacking: 4,\n    };\n    this.position = {\n      horizontal: {\n        distance: 12,\n        position: 'left',\n      },\n      vertical: {\n        distance: 12,\n        gap: 10,\n        position: 'bottom',\n      },\n    };\n    this.theme = 'material';\n\n    // The following merges the custom options into the notifier config, respecting the already set default values\n    // This linear, more explicit and code-sizy workflow is preferred here over a recursive one (because we know the object structure)\n    // Technical sidenote: Objects are merged, other types of values simply overwritten / copied\n    if (customOptions.theme !== undefined) {\n      this.theme = customOptions.theme;\n    }\n    if (customOptions.animations !== undefined) {\n      if (customOptions.animations.enabled !== undefined) {\n        this.animations.enabled = customOptions.animations.enabled;\n      }\n      if (customOptions.animations.overlap !== undefined) {\n        this.animations.overlap = customOptions.animations.overlap;\n      }\n      if (customOptions.animations.hide !== undefined) {\n        Object.assign(this.animations.hide, customOptions.animations.hide);\n      }\n      if (customOptions.animations.shift !== undefined) {\n        Object.assign(this.animations.shift, customOptions.animations.shift);\n      }\n      if (customOptions.animations.show !== undefined) {\n        Object.assign(this.animations.show, customOptions.animations.show);\n      }\n    }\n    if (customOptions.behaviour !== undefined) {\n      Object.assign(this.behaviour, customOptions.behaviour);\n    }\n    if (customOptions.position !== undefined) {\n      if (customOptions.position.horizontal !== undefined) {\n        Object.assign(this.position.horizontal, customOptions.position.horizontal);\n      }\n      if (customOptions.position.vertical !== undefined) {\n        Object.assign(this.position.vertical, customOptions.position.vertical);\n      }\n    }\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\nimport { NotifierConfig, NotifierOptions } from './models/notifier-config.model';\n\n/**\n * Injection Token for notifier options\n */\nexport const NotifierOptionsToken: InjectionToken<NotifierOptions> = new InjectionToken<NotifierOptions>(\n  '[angular-notifier] Notifier Options',\n);\n\n/**\n * Injection Token for notifier configuration\n */\nexport const NotifierConfigToken: InjectionToken<NotifierConfig> = new InjectionToken<NotifierConfig>('[anuglar-notifier] Notifier Config');\n","import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\nimport { NotifierAction } from '../models/notifier-action.model';\n\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\n@Injectable()\nexport class NotifierQueueService {\n  /**\n   * Stream of actions, subscribable from outside\n   */\n  public readonly actionStream: Subject<NotifierAction>;\n\n  /**\n   * Queue of actions\n   */\n  private actionQueue: Array<NotifierAction>;\n\n  /**\n   * Flag, true if some action is currently in progress\n   */\n  private isActionInProgress: boolean;\n\n  /**\n   * Constructor\n   */\n  public constructor() {\n    this.actionStream = new Subject<NotifierAction>();\n    this.actionQueue = [];\n    this.isActionInProgress = false;\n  }\n\n  /**\n   * Push a new action to the queue, and try to run it\n   *\n   * @param action Action object\n   */\n  public push(action: NotifierAction): void {\n    this.actionQueue.push(action);\n    this.tryToRunNextAction();\n  }\n\n  /**\n   * Continue with the next action (called when the current action is finished)\n   */\n  public continue(): void {\n    this.isActionInProgress = false;\n    this.tryToRunNextAction();\n  }\n\n  /**\n   * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n   */\n  private tryToRunNextAction(): void {\n    if (this.isActionInProgress || this.actionQueue.length === 0) {\n      return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n    }\n    this.isActionInProgress = true;\n    this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n  }\n}\n","import { Inject, Injectable } from '@angular/core';\n\nimport { NotifierConfig } from '../models/notifier-config.model';\nimport { NotifierNotificationOptions } from '../models/notifier-notification.model';\nimport { NotifierConfigToken } from '../notifier.tokens';\nimport { NotifierQueueService } from './notifier-queue.service';\n\n/**\n * Notifier service\n *\n * This service provides access to the public notifier API. Once injected into a component, directive, pipe, service, or any other building\n * block of an applications, it can be used to show new notifications, and hide existing ones. Internally, it transforms API calls into\n * actions, which then get thrown into the action queue - eventually being processed at the right moment.\n */\n@Injectable()\nexport class NotifierService {\n  /**\n   * Notifier queue service\n   */\n  private readonly queueService: NotifierQueueService;\n\n  /**\n   * Notifier configuration\n   */\n  private readonly config: NotifierConfig;\n\n  /**\n   * Constructor\n   *\n   * @param notifierQueueService Notifier queue service\n   * @param config               Notifier configuration, optionally injected as a dependency\n   */\n  public constructor(notifierQueueService: NotifierQueueService, @Inject(NotifierConfigToken) config: NotifierConfig) {\n    this.queueService = notifierQueueService;\n    this.config = config;\n  }\n\n  /**\n   * Get the notifier configuration\n   *\n   * @returns Notifier configuration\n   */\n  public getConfig(): NotifierConfig {\n    return this.config;\n  }\n\n  /**\n   * API: Show a new notification\n   *\n   * @param notificationOptions Notification options\n   */\n  public show(notificationOptions: NotifierNotificationOptions): void {\n    this.queueService.push({\n      payload: notificationOptions,\n      type: 'SHOW',\n    });\n  }\n\n  /**\n   * API: Hide a specific notification, given its ID\n   *\n   * @param notificationId ID of the notification to hide\n   */\n  public hide(notificationId: string): void {\n    this.queueService.push({\n      payload: notificationId,\n      type: 'HIDE',\n    });\n  }\n\n  /**\n   * API: Hide the newest notification\n   */\n  public hideNewest(): void {\n    this.queueService.push({\n      type: 'HIDE_NEWEST',\n    });\n  }\n\n  /**\n   * API: Hide the oldest notification\n   */\n  public hideOldest(): void {\n    this.queueService.push({\n      type: 'HIDE_OLDEST',\n    });\n  }\n\n  /**\n   * API: Hide all notifications at once\n   */\n  public hideAll(): void {\n    this.queueService.push({\n      type: 'HIDE_ALL',\n    });\n  }\n\n  /**\n   * API: Shortcut for showing a new notification\n   *\n   * @param type             Type of the notification\n   * @param message          Message of the notification\n   * @param [notificationId] Unique ID for the notification (optional)\n   */\n  public notify(type: string, message: string, notificationId?: string): void {\n    const notificationOptions: NotifierNotificationOptions = {\n      message,\n      type,\n    };\n    if (notificationId !== undefined) {\n      notificationOptions.id = notificationId;\n    }\n    this.show(notificationOptions);\n  }\n}\n","import { ChangeDetectionStrategy, ChangeDetectorRef, Component, OnDestroy } from '@angular/core';\nimport { Subscription } from 'rxjs';\n\nimport { NotifierAction } from '../models/notifier-action.model';\nimport { NotifierConfig } from '../models/notifier-config.model';\nimport { NotifierNotification } from '../models/notifier-notification.model';\nimport { NotifierService } from '../services/notifier.service';\nimport { NotifierQueueService } from '../services/notifier-queue.service';\nimport { NotifierNotificationComponent } from './notifier-notification.component';\n\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush, // (#perfmatters)\n  host: {\n    class: 'notifier__container',\n  },\n  selector: 'notifier-container',\n  templateUrl: './notifier-container.component.html',\n})\nexport class NotifierContainerComponent implements OnDestroy {\n  /**\n   * List of currently somewhat active notifications\n   */\n  public notifications: Array<NotifierNotification>;\n\n  /**\n   * Change detector\n   */\n  private readonly changeDetector: ChangeDetectorRef;\n\n  /**\n   * Notifier queue service\n   */\n  private readonly queueService: NotifierQueueService;\n\n  /**\n   * Notifier configuration\n   */\n  private readonly config: NotifierConfig;\n\n  /**\n   * Queue service observable subscription (saved for cleanup)\n   */\n  private queueServiceSubscription: Subscription;\n\n  /**\n   * Promise resolve function reference, temporarily used while the notification child component gets created\n   */\n  private tempPromiseResolver: () => void;\n\n  /**\n   * Constructor\n   *\n   * @param changeDetector       Change detector, used for manually triggering change detection runs\n   * @param notifierQueueService Notifier queue service\n   * @param notifierService      Notifier service\n   */\n  public constructor(changeDetector: ChangeDetectorRef, notifierQueueService: NotifierQueueService, notifierService: NotifierService) {\n    this.changeDetector = changeDetector;\n    this.queueService = notifierQueueService;\n    this.config = notifierService.getConfig();\n    this.notifications = [];\n\n    // Connects this component up to the action queue, then handle incoming actions\n    this.queueServiceSubscription = this.queueService.actionStream.subscribe((action: NotifierAction) => {\n      this.handleAction(action).then(() => {\n        this.queueService.continue();\n      });\n    });\n  }\n\n  /**\n   * Component destroyment lifecycle hook, cleans up the observable subsciption\n   */\n  public ngOnDestroy(): void {\n    if (this.queueServiceSubscription) {\n      this.queueServiceSubscription.unsubscribe();\n    }\n  }\n\n  /**\n   * Notification identifier, used as the ngFor trackby function\n   *\n   * @param   index        Index\n   * @param   notification Notifier notification\n   * @returns Notification ID as the unique identnfier\n   */\n  public identifyNotification(index: number, notification: NotifierNotification): string {\n    return notification.id;\n  }\n\n  /**\n   * Event handler, handles clicks on notification dismiss buttons\n   *\n   * @param notificationId ID of the notification to dismiss\n   */\n  public onNotificationDismiss(notificationId: string): void {\n    this.queueService.push({\n      payload: notificationId,\n      type: 'HIDE',\n    });\n  }\n\n  /**\n   * Event handler, handles notification ready events\n   *\n   * @param notificationComponent Notification component reference\n   */\n  public onNotificationReady(notificationComponent: NotifierNotificationComponent): void {\n    const currentNotification: NotifierNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n    currentNotification.component = notificationComponent; // Save the new omponent reference\n    this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n  }\n\n  /**\n   * Handle incoming actions by mapping action types to methods, and then running them\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n  private handleAction(action: NotifierAction): Promise<void> {\n    switch (\n      action.type // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n    ) {\n      case 'SHOW':\n        return this.handleShowAction(action);\n      case 'HIDE':\n        return this.handleHideAction(action);\n      case 'HIDE_OLDEST':\n        return this.handleHideOldestAction(action);\n      case 'HIDE_NEWEST':\n        return this.handleHideNewestAction(action);\n      case 'HIDE_ALL':\n        return this.handleHideAllAction();\n      default:\n        return new Promise<void>((resolve: () => void) => {\n          resolve(); // Ignore unknown action types\n        });\n    }\n  }\n\n  /**\n   * Show a new notification\n   *\n   * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n  private handleShowAction(action: NotifierAction): Promise<void> {\n    return new Promise<void>((resolve: () => void) => {\n      this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n      this.addNotificationToList(new NotifierNotification(action.payload));\n    });\n  }\n\n  /**\n   * Continue to show a new notification (after the notification components is initialized / created / rendered).\n   *\n   * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n   * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n   * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n   * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n   *\n   * @param notification New notification to show\n   */\n  private continueHandleShowAction(notification: NotifierNotification): void {\n    // First (which means only one) notification in the list?\n    const numberOfNotifications: number = this.notifications.length;\n    if (numberOfNotifications === 1) {\n      notification.component.show().then(this.tempPromiseResolver); // Done\n    } else {\n      const implicitStackingLimit = 2;\n\n      // Stacking enabled? (stacking value below 2 means stacking is disabled)\n      if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n        this.notifications[0].component.hide().then(() => {\n          this.removeNotificationFromList(this.notifications[0]);\n          notification.component.show().then(this.tempPromiseResolver); // Done\n        });\n      } else {\n        const stepPromises: Array<Promise<void>> = [];\n\n        // Are there now too many notifications?\n        if (numberOfNotifications > this.config.behaviour.stacking) {\n          const oldNotifications: Array<NotifierNotification> = this.notifications.slice(1, numberOfNotifications - 1);\n\n          // Are animations enabled?\n          if (this.config.animations.enabled) {\n            // Is animation overlap enabled?\n            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n              stepPromises.push(this.notifications[0].component.hide());\n              setTimeout(() => {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              }, this.config.animations.hide.speed - this.config.animations.overlap);\n              setTimeout(() => {\n                stepPromises.push(notification.component.show());\n              }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n            } else {\n              stepPromises.push(\n                new Promise<void>((resolve: () => void) => {\n                  this.notifications[0].component.hide().then(() => {\n                    this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                      notification.component.show().then(resolve);\n                    });\n                  });\n                }),\n              );\n            }\n          } else {\n            stepPromises.push(this.notifications[0].component.hide());\n            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n            stepPromises.push(notification.component.show());\n          }\n        } else {\n          const oldNotifications: Array<NotifierNotification> = this.notifications.slice(0, numberOfNotifications - 1);\n\n          // Are animations enabled?\n          if (this.config.animations.enabled) {\n            // Is animation overlap enabled?\n            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              setTimeout(() => {\n                stepPromises.push(notification.component.show());\n              }, this.config.animations.shift.speed - this.config.animations.overlap);\n            } else {\n              stepPromises.push(\n                new Promise<void>((resolve: () => void) => {\n                  this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                    notification.component.show().then(resolve);\n                  });\n                }),\n              );\n            }\n          } else {\n            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n            stepPromises.push(notification.component.show());\n          }\n        }\n\n        Promise.all(stepPromises).then(() => {\n          if (numberOfNotifications > this.config.behaviour.stacking) {\n            this.removeNotificationFromList(this.notifications[0]);\n          }\n          this.tempPromiseResolver();\n        }); // Done\n      }\n    }\n  }\n\n  /**\n   * Hide an existing notification\n   *\n   * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n   * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n   * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n   *\n   * @param   action Action object, payload contains the notification ID\n   * @returns Promise, resolved when done\n   */\n  private handleHideAction(action: NotifierAction): Promise<void> {\n    return new Promise<void>((resolve: () => void) => {\n      const stepPromises: Array<Promise<void>> = [];\n\n      // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n      const notification: NotifierNotification | undefined = this.findNotificationById(action.payload);\n      if (notification === undefined) {\n        resolve();\n        return;\n      }\n\n      // Get older notifications\n      const notificationIndex: number | undefined = this.findNotificationIndexById(action.payload);\n      if (notificationIndex === undefined) {\n        resolve();\n        return;\n      }\n      const oldNotifications: Array<NotifierNotification> = this.notifications.slice(0, notificationIndex);\n\n      // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n      if (oldNotifications.length > 0) {\n        // Are animations enabled?\n        if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n          // Is animation overlap enabled?\n          if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n            stepPromises.push(notification.component.hide());\n            setTimeout(() => {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n            }, this.config.animations.hide.speed - this.config.animations.overlap);\n          } else {\n            notification.component.hide().then(() => {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n            });\n          }\n        } else {\n          stepPromises.push(notification.component.hide());\n          stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n        }\n      } else {\n        stepPromises.push(notification.component.hide());\n      }\n\n      // Wait until both hiding and shifting is done, then remove the notification from the list\n      Promise.all(stepPromises).then(() => {\n        this.removeNotificationFromList(notification);\n        resolve(); // Done\n      });\n    });\n  }\n\n  /**\n   * Hide the oldest notification (bridge to handleHideAction)\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n  private handleHideOldestAction(action: NotifierAction): Promise<void> {\n    // Are there any notifications? (prevent accidential errors)\n    if (this.notifications.length === 0) {\n      return new Promise<void>((resolve: () => void) => {\n        resolve();\n      }); // Done\n    } else {\n      action.payload = this.notifications[0].id;\n      return this.handleHideAction(action);\n    }\n  }\n\n  /**\n   * Hide the newest notification (bridge to handleHideAction)\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n  private handleHideNewestAction(action: NotifierAction): Promise<void> {\n    // Are there any notifications? (prevent accidential errors)\n    if (this.notifications.length === 0) {\n      return new Promise<void>((resolve: () => void) => {\n        resolve();\n      }); // Done\n    } else {\n      action.payload = this.notifications[this.notifications.length - 1].id;\n      return this.handleHideAction(action);\n    }\n  }\n\n  /**\n   * Hide all notifications at once\n   *\n   * @returns Promise, resolved when done\n   */\n  private handleHideAllAction(): Promise<void> {\n    return new Promise<void>((resolve: () => void) => {\n      // Are there any notifications? (prevent accidential errors)\n      const numberOfNotifications: number = this.notifications.length;\n      if (numberOfNotifications === 0) {\n        resolve(); // Done\n        return;\n      }\n\n      // Are animations enabled?\n      if (\n        this.config.animations.enabled &&\n        this.config.animations.hide.speed > 0 &&\n        this.config.animations.hide.offset !== false &&\n        this.config.animations.hide.offset > 0\n      ) {\n        for (let i: number = numberOfNotifications - 1; i >= 0; i--) {\n          const animationOffset: number = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n          setTimeout(() => {\n            this.notifications[i].component.hide().then(() => {\n              // Are we done here, was this the last notification to be hidden?\n              if (\n                (this.config.position.vertical.position === 'top' && i === 0) ||\n                (this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1)\n              ) {\n                this.removeAllNotificationsFromList();\n                resolve(); // Done\n              }\n            });\n          }, this.config.animations.hide.offset * animationOffset);\n        }\n      } else {\n        const stepPromises: Array<Promise<void>> = [];\n        for (let i: number = numberOfNotifications - 1; i >= 0; i--) {\n          stepPromises.push(this.notifications[i].component.hide());\n        }\n        Promise.all(stepPromises).then(() => {\n          this.removeAllNotificationsFromList();\n          resolve(); // Done\n        });\n      }\n    });\n  }\n\n  /**\n   * Shift multiple notifications at once\n   *\n   * @param   notifications List containing the notifications to be shifted\n   * @param   distance      Distance to shift (in px)\n   * @param   toMakePlace   Flag, defining in which direciton to shift\n   * @returns Promise, resolved when done\n   */\n  private shiftNotifications(notifications: Array<NotifierNotification>, distance: number, toMakePlace: boolean): Promise<void> {\n    return new Promise<void>((resolve: () => void) => {\n      // Are there any notifications to shift?\n      if (notifications.length === 0) {\n        resolve();\n        return;\n      }\n\n      const notificationPromises: Array<Promise<void>> = [];\n      for (let i: number = notifications.length - 1; i >= 0; i--) {\n        notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n      }\n      Promise.all(notificationPromises).then(resolve); // Done\n    });\n  }\n\n  /**\n   * Add a new notification to the list of notifications (triggers change detection)\n   *\n   * @param notification Notification to add to the list of notifications\n   */\n  private addNotificationToList(notification: NotifierNotification): void {\n    this.notifications.push(notification);\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n\n  /**\n   * Remove an existing notification from the list of notifications (triggers change detection)\n   *\n   * @param notification Notification to be removed from the list of notifications\n   */\n  private removeNotificationFromList(notification: NotifierNotification): void {\n    this.notifications = this.notifications.filter((item: NotifierNotification) => item.component !== notification.component);\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n\n  /**\n   * Remove all notifications from the list (triggers change detection)\n   */\n  private removeAllNotificationsFromList(): void {\n    this.notifications = [];\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n\n  /**\n   * Helper: Find a notification in the notification list by a given notification ID\n   *\n   * @param   notificationId Notification ID, used for finding notification\n   * @returns Notification, undefined if not found\n   */\n  private findNotificationById(notificationId: string): NotifierNotification | undefined {\n    return this.notifications.find((currentNotification: NotifierNotification) => currentNotification.id === notificationId);\n  }\n\n  /**\n   * Helper: Find a notification's index by a given notification ID\n   *\n   * @param   notificationId Notification ID, used for finding a notification's index\n   * @returns Notification index, undefined if not found\n   */\n  private findNotificationIndexById(notificationId: string): number | undefined {\n    const notificationIndex: number = this.notifications.findIndex(\n      (currentNotification: NotifierNotification) => currentNotification.id === notificationId,\n    );\n    return notificationIndex !== -1 ? notificationIndex : undefined;\n  }\n}\n","import { NotifierAnimationPreset, NotifierAnimationPresetKeyframes } from '../models/notifier-animation.model';\n\n/**\n * Fade animation preset\n */\nexport const fade: NotifierAnimationPreset = {\n  hide: (): NotifierAnimationPresetKeyframes => {\n    return {\n      from: {\n        opacity: '1',\n      },\n      to: {\n        opacity: '0',\n      },\n    };\n  },\n  show: (): NotifierAnimationPresetKeyframes => {\n    return {\n      from: {\n        opacity: '0',\n      },\n      to: {\n        opacity: '1',\n      },\n    };\n  },\n};\n","import { NotifierAnimationPreset, NotifierAnimationPresetKeyframes } from '../models/notifier-animation.model';\nimport { NotifierConfig } from '../models/notifier-config.model';\nimport { NotifierNotification } from '../models/notifier-notification.model';\n\n/**\n * Slide animation preset\n */\nexport const slide: NotifierAnimationPreset = {\n  hide: (notification: NotifierNotification): NotifierAnimationPresetKeyframes => {\n    // Prepare variables\n    const config: NotifierConfig = notification.component.getConfig();\n    const shift: number = notification.component.getShift();\n    let from: {\n      [animatablePropertyName: string]: string;\n    };\n    let to: {\n      [animatablePropertyName: string]: string;\n    };\n\n    // Configure variables, depending on configuration and component\n    if (config.position.horizontal.position === 'left') {\n      from = {\n        transform: `translate3d( 0, ${shift}px, 0 )`,\n      };\n      to = {\n        transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), ${shift}px, 0 )`,\n      };\n    } else if (config.position.horizontal.position === 'right') {\n      from = {\n        transform: `translate3d( 0, ${shift}px, 0 )`,\n      };\n      to = {\n        transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), ${shift}px, 0 )`,\n      };\n    } else {\n      let horizontalPosition: string;\n      if (config.position.vertical.position === 'top') {\n        horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n      } else {\n        horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n      }\n      from = {\n        transform: `translate3d( -50%, ${shift}px, 0 )`,\n      };\n      to = {\n        transform: `translate3d( -50%, ${horizontalPosition}, 0 )`,\n      };\n    }\n\n    // Done\n    return {\n      from,\n      to,\n    };\n  },\n  show: (notification: NotifierNotification): NotifierAnimationPresetKeyframes => {\n    // Prepare variables\n    const config: NotifierConfig = notification.component.getConfig();\n    let from: {\n      [animatablePropertyName: string]: string;\n    };\n    let to: {\n      [animatablePropertyName: string]: string;\n    };\n\n    // Configure variables, depending on configuration and component\n    if (config.position.horizontal.position === 'left') {\n      from = {\n        transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), 0, 0 )`,\n      };\n      to = {\n        transform: 'translate3d( 0, 0, 0 )',\n      };\n    } else if (config.position.horizontal.position === 'right') {\n      from = {\n        transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), 0, 0 )`,\n      };\n      to = {\n        transform: 'translate3d( 0, 0, 0 )',\n      };\n    } else {\n      let horizontalPosition: string;\n      if (config.position.vertical.position === 'top') {\n        horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n      } else {\n        horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n      }\n      from = {\n        transform: `translate3d( -50%, ${horizontalPosition}, 0 )`,\n      };\n      to = {\n        transform: 'translate3d( -50%, 0, 0 )',\n      };\n    }\n\n    // Done\n    return {\n      from,\n      to,\n    };\n  },\n};\n","import { Injectable } from '@angular/core';\n\nimport { fade } from '../animation-presets/fade.animation-preset';\nimport { slide } from '../animation-presets/slide.animation-preset';\nimport { NotifierAnimationData, NotifierAnimationPreset, NotifierAnimationPresetKeyframes } from '../models/notifier-animation.model';\nimport { NotifierNotification } from '../models/notifier-notification.model';\n\n/**\n * Notifier animation service\n */\n@Injectable()\nexport class NotifierAnimationService {\n  /**\n   * List of animation presets (currently static)\n   */\n  private readonly animationPresets: {\n    [animationPresetName: string]: NotifierAnimationPreset;\n  };\n\n  /**\n   * Constructor\n   */\n  public constructor() {\n    this.animationPresets = {\n      fade,\n      slide,\n    };\n  }\n\n  /**\n   * Get animation data\n   *\n   * This method generates all data the Web Animations API needs to animate our notification. The result depends on both the animation\n   * direction (either in or out) as well as the notifications (and its attributes) itself.\n   *\n   * @param   direction    Animation direction, either in or out\n   * @param   notification Notification the animation data should be generated for\n   * @returns Animation information\n   */\n  public getAnimationData(direction: 'show' | 'hide', notification: NotifierNotification): NotifierAnimationData {\n    // Get all necessary animation data\n    let keyframes: NotifierAnimationPresetKeyframes;\n    let duration: number;\n    let easing: string;\n    if (direction === 'show') {\n      keyframes = this.animationPresets[notification.component.getConfig().animations.show.preset].show(notification);\n      duration = notification.component.getConfig().animations.show.speed;\n      easing = notification.component.getConfig().animations.show.easing;\n    } else {\n      keyframes = this.animationPresets[notification.component.getConfig().animations.hide.preset].hide(notification);\n      duration = notification.component.getConfig().animations.hide.speed;\n      easing = notification.component.getConfig().animations.hide.easing;\n    }\n\n    // Build and return animation data\n    return {\n      keyframes: [keyframes.from, keyframes.to],\n      options: {\n        duration,\n        easing,\n        fill: 'forwards', // Keep the newly painted state after the animation finished\n      },\n    };\n  }\n}\n","import { Injectable } from '@angular/core';\n\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\n@Injectable()\nexport class NotifierTimerService {\n  /**\n   * Timestamp (in ms), created in the moment the timer starts\n   */\n  private now: number;\n\n  /**\n   * Remaining time (in ms)\n   */\n  private remaining: number;\n\n  /**\n   * Timeout ID, used for clearing the timeout later on\n   */\n  private timerId: number;\n\n  /**\n   * Promise resolve function, eventually getting called once the timer finishes\n   */\n  private finishPromiseResolver: () => void;\n\n  /**\n   * Constructor\n   */\n  public constructor() {\n    this.now = 0;\n    this.remaining = 0;\n  }\n\n  /**\n   * Start (or resume) the timer\n   *\n   * @param   duration Timer duration, in ms\n   * @returns          Promise, resolved once the timer finishes\n   */\n  public start(duration: number): Promise<void> {\n    return new Promise<void>((resolve: () => void) => {\n      // For the first run ...\n      this.remaining = duration;\n\n      // Setup, then start the timer\n      this.finishPromiseResolver = resolve;\n      this.continue();\n    });\n  }\n\n  /**\n   * Pause the timer\n   */\n  public pause(): void {\n    clearTimeout(this.timerId);\n    this.remaining -= new Date().getTime() - this.now;\n  }\n\n  /**\n   * Continue the timer\n   */\n  public continue(): void {\n    this.now = new Date().getTime();\n    this.timerId = window.setTimeout(() => {\n      this.finish();\n    }, this.remaining);\n  }\n\n  /**\n   * Stop the timer\n   */\n  public stop(): void {\n    clearTimeout(this.timerId);\n    this.remaining = 0;\n  }\n\n  /**\n   * Finish up the timeout by resolving the timer promise\n   */\n  private finish(): void {\n    this.finishPromiseResolver();\n  }\n}\n","import { AfterViewInit, ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2 } from '@angular/core';\n\nimport { NotifierAnimationData } from '../models/notifier-animation.model';\nimport { NotifierConfig } from '../models/notifier-config.model';\nimport { NotifierNotification } from '../models/notifier-notification.model';\nimport { NotifierService } from '../services/notifier.service';\nimport { NotifierAnimationService } from '../services/notifier-animation.service';\nimport { NotifierTimerService } from '../services/notifier-timer.service';\n\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush, // (#perfmatters)\n  host: {\n    '(click)': 'onNotificationClick()',\n    '(mouseout)': 'onNotificationMouseout()',\n    '(mouseover)': 'onNotificationMouseover()',\n    class: 'notifier__notification',\n  },\n  providers: [\n    // We provide the timer to the component's local injector, so that every notification components gets its own\n    // instance of the timer service, thus running their timers independently from each other\n    NotifierTimerService,\n  ],\n  selector: 'notifier-notification',\n  templateUrl: './notifier-notification.component.html',\n})\nexport class NotifierNotificationComponent implements AfterViewInit {\n  /**\n   * Input: Notification object, contains all details necessary to construct the notification\n   */\n  @Input()\n  public notification: NotifierNotification;\n\n  /**\n   * Output: Ready event, handles the initialization success by emitting a reference to this notification component\n   */\n  @Output()\n  public ready: EventEmitter<NotifierNotificationComponent>;\n\n  /**\n   * Output: Dismiss event, handles the click on the dismiss button by emitting the notification ID of this notification component\n   */\n  @Output()\n  public dismiss: EventEmitter<string>;\n\n  /**\n   * Notifier configuration\n   */\n  public readonly config: NotifierConfig;\n\n  /**\n   * Notifier timer service\n   */\n  private readonly timerService: NotifierTimerService;\n\n  /**\n   * Notifier animation service\n   */\n  private readonly animationService: NotifierAnimationService;\n\n  /**\n   * Angular renderer, used to preserve the overall DOM abstraction & independence\n   */\n  private readonly renderer: Renderer2;\n\n  /**\n   * Native element reference, used for manipulating DOM properties\n   */\n  private readonly element: HTMLElement;\n\n  /**\n   * Current notification height, calculated and cached here (#perfmatters)\n   */\n  private elementHeight: number;\n\n  /**\n   * Current notification width, calculated and cached here (#perfmatters)\n   */\n  private elementWidth: number;\n\n  /**\n   * Current notification shift, calculated and cached here (#perfmatters)\n   */\n  private elementShift: number;\n\n  /**\n   * Constructor\n   *\n   * @param elementRef               Reference to the component's element\n   * @param renderer                 Angular renderer\n   * @param notifierService          Notifier service\n   * @param notifierTimerService     Notifier timer service\n   * @param notifierAnimationService Notifier animation service\n   */\n  public constructor(\n    elementRef: ElementRef,\n    renderer: Renderer2,\n    notifierService: NotifierService,\n    notifierTimerService: NotifierTimerService,\n    notifierAnimationService: NotifierAnimationService,\n  ) {\n    this.config = notifierService.getConfig();\n    this.ready = new EventEmitter<NotifierNotificationComponent>();\n    this.dismiss = new EventEmitter<string>();\n    this.timerService = notifierTimerService;\n    this.animationService = notifierAnimationService;\n    this.renderer = renderer;\n    this.element = elementRef.nativeElement;\n    this.elementShift = 0;\n  }\n\n  /**\n   * Component after view init lifecycle hook, setts up the component and then emits the ready event\n   */\n  public ngAfterViewInit(): void {\n    this.setup();\n    this.elementHeight = this.element.offsetHeight;\n    this.elementWidth = this.element.offsetWidth;\n    this.ready.emit(this);\n  }\n\n  /**\n   * Get the notifier config\n   *\n   * @returns Notifier configuration\n   */\n  public getConfig(): NotifierConfig {\n    return this.config;\n  }\n\n  /**\n   * Get notification element height (in px)\n   *\n   * @returns Notification element height (in px)\n   */\n  public getHeight(): number {\n    return this.elementHeight;\n  }\n\n  /**\n   * Get notification element width (in px)\n   *\n   * @returns Notification element height (in px)\n   */\n  public getWidth(): number {\n    return this.elementWidth;\n  }\n\n  /**\n   * Get notification shift offset (in px)\n   *\n   * @returns Notification element shift offset (in px)\n   */\n  public getShift(): number {\n    return this.elementShift;\n  }\n\n  /**\n   * Show (animate in) this notification\n   *\n   * @returns Promise, resolved when done\n   */\n  public show(): Promise<void> {\n    return new Promise<void>((resolve: () => void) => {\n      // Are animations enabled?\n      if (this.config.animations.enabled && this.config.animations.show.speed > 0) {\n        // Get animation data\n        const animationData: NotifierAnimationData = this.animationService.getAnimationData('show', this.notification);\n\n        // Set initial styles (styles before animation), prevents quick flicker when animation starts\n        const animatedProperties: Array<string> = Object.keys(animationData.keyframes[0]);\n        for (let i: number = animatedProperties.length - 1; i >= 0; i--) {\n          this.renderer.setStyle(this.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n        }\n\n        // Animate notification in\n        this.renderer.setStyle(this.element, 'visibility', 'visible');\n        const animation: Animation = this.element.animate(animationData.keyframes, animationData.options);\n        animation.onfinish = () => {\n          this.startAutoHideTimer();\n          resolve(); // Done\n        };\n      } else {\n        // Show notification\n        this.renderer.setStyle(this.element, 'visibility', 'visible');\n        this.startAutoHideTimer();\n        resolve(); // Done\n      }\n    });\n  }\n\n  /**\n   * Hide (animate out) this notification\n   *\n   * @returns Promise, resolved when done\n   */\n  public hide(): Promise<void> {\n    return new Promise<void>((resolve: () => void) => {\n      this.stopAutoHideTimer();\n\n      // Are animations enabled?\n      if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n        const animationData: NotifierAnimationData = this.animationService.getAnimationData('hide', this.notification);\n        const animation: Animation = this.element.animate(animationData.keyframes, animationData.options);\n        animation.onfinish = () => {\n          resolve(); // Done\n        };\n      } else {\n        resolve(); // Done\n      }\n    });\n  }\n\n  /**\n   * Shift (move) this notification\n   *\n   * @param   distance         Distance to shift (in px)\n   * @param   shiftToMakePlace Flag, defining in which direction to shift\n   * @returns Promise, resolved when done\n   */\n  public shift(distance: number, shiftToMakePlace: boolean): Promise<void> {\n    return new Promise<void>((resolve: () => void) => {\n      // Calculate new position (position after the shift)\n      let newElementShift: number;\n      if (\n        (this.config.position.vertical.position === 'top' && shiftToMakePlace) ||\n        (this.config.position.vertical.position === 'bottom' && !shiftToMakePlace)\n      ) {\n        newElementShift = this.elementShift + distance + this.config.position.vertical.gap;\n      } else {\n        newElementShift = this.elementShift - distance - this.config.position.vertical.gap;\n      }\n      const horizontalPosition: string = this.config.position.horizontal.position === 'middle' ? '-50%' : '0';\n\n      // Are animations enabled?\n      if (this.config.animations.enabled && this.config.animations.shift.speed > 0) {\n        const animationData: NotifierAnimationData = {\n          // TODO: Extract into animation service\n          keyframes: [\n            {\n              transform: `translate3d( ${horizontalPosition}, ${this.elementShift}px, 0 )`,\n            },\n            {\n              transform: `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`,\n            },\n          ],\n          options: {\n            duration: this.config.animations.shift.speed,\n            easing: this.config.animations.shift.easing,\n            fill: 'forwards',\n          },\n        };\n        this.elementShift = newElementShift;\n        const animation: Animation = this.element.animate(animationData.keyframes, animationData.options);\n        animation.onfinish = () => {\n          resolve(); // Done\n        };\n      } else {\n        this.renderer.setStyle(this.element, 'transform', `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`);\n        this.elementShift = newElementShift;\n        resolve(); // Done\n      }\n    });\n  }\n\n  /**\n   * Handle click on dismiss button\n   */\n  public onClickDismiss(): void {\n    this.dismiss.emit(this.notification.id);\n  }\n\n  /**\n   * Handle mouseover over notification area\n   */\n  public onNotificationMouseover(): void {\n    if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n      this.pauseAutoHideTimer();\n    } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n      this.stopAutoHideTimer();\n    }\n  }\n\n  /**\n   * Handle mouseout from notification area\n   */\n  public onNotificationMouseout(): void {\n    if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n      this.continueAutoHideTimer();\n    } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n      this.startAutoHideTimer();\n    }\n  }\n\n  /**\n   * Handle click on notification area\n   */\n  public onNotificationClick(): void {\n    if (this.config.behaviour.onClick === 'hide') {\n      this.onClickDismiss();\n    }\n  }\n\n  /**\n   * Start the auto hide timer (if enabled)\n   */\n  private startAutoHideTimer(): void {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.start(this.config.behaviour.autoHide).then(() => {\n        this.onClickDismiss();\n      });\n    }\n  }\n\n  /**\n   * Pause the auto hide timer (if enabled)\n   */\n  private pauseAutoHideTimer(): void {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.pause();\n    }\n  }\n\n  /**\n   * Continue the auto hide timer (if enabled)\n   */\n  private continueAutoHideTimer(): void {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.continue();\n    }\n  }\n\n  /**\n   * Stop the auto hide timer (if enabled)\n   */\n  private stopAutoHideTimer(): void {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.stop();\n    }\n  }\n\n  /**\n   * Initial notification setup\n   */\n  private setup(): void {\n    // Set start position (initially the exact same for every new notification)\n    if (this.config.position.horizontal.position === 'left') {\n      this.renderer.setStyle(this.element, 'left', `${this.config.position.horizontal.distance}px`);\n    } else if (this.config.position.horizontal.position === 'right') {\n      this.renderer.setStyle(this.element, 'right', `${this.config.position.horizontal.distance}px`);\n    } else {\n      this.renderer.setStyle(this.element, 'left', '50%');\n      // Let's get the GPU handle some work as well (#perfmatters)\n      this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n    }\n    if (this.config.position.vertical.position === 'top') {\n      this.renderer.setStyle(this.element, 'top', `${this.config.position.vertical.distance}px`);\n    } else {\n      this.renderer.setStyle(this.element, 'bottom', `${this.config.position.vertical.distance}px`);\n    }\n\n    // Add classes (responsible for visual design)\n    this.renderer.addClass(this.element, `notifier__notification--${this.notification.type}`);\n    this.renderer.addClass(this.element, `notifier__notification--${this.config.theme}`);\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { ModuleWithProviders, NgModule } from '@angular/core';\n\nimport { NotifierContainerComponent } from './components/notifier-container.component';\nimport { NotifierNotificationComponent } from './components/notifier-notification.component';\nimport { NotifierConfig, NotifierOptions } from './models/notifier-config.model';\nimport { NotifierConfigToken, NotifierOptionsToken } from './notifier.tokens';\nimport { NotifierService } from './services/notifier.service';\nimport { NotifierAnimationService } from './services/notifier-animation.service';\nimport { NotifierQueueService } from './services/notifier-queue.service';\n\n/**\n * Factory for a notifier configuration with custom options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @param   options - Custom notifier options\n * @returns - Notifier configuration as result\n */\nexport function notifierCustomConfigFactory(options: NotifierOptions): NotifierConfig {\n  return new NotifierConfig(options);\n}\n\n/**\n * Factory for a notifier configuration with default options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @returns - Notifier configuration as result\n */\nexport function notifierDefaultConfigFactory(): NotifierConfig {\n  return new NotifierConfig({});\n}\n\n/**\n * Notifier module\n */\n@NgModule({\n  declarations: [NotifierContainerComponent, NotifierNotificationComponent],\n  exports: [NotifierContainerComponent],\n  imports: [CommonModule],\n  providers: [\n    NotifierAnimationService,\n    NotifierService,\n    NotifierQueueService,\n\n    // Provide the default notifier configuration if just the module is imported\n    {\n      provide: NotifierConfigToken,\n      useFactory: notifierDefaultConfigFactory,\n    },\n  ],\n})\nexport class NotifierModule {\n  /**\n   * Setup the notifier module with custom providers, in this case with a custom configuration based on the givne options\n   *\n   * @param   [options={}] - Custom notifier options\n   * @returns - Notifier module with custom providers\n   */\n  public static withConfig(options: NotifierOptions = {}): ModuleWithProviders {\n    return {\n      ngModule: NotifierModule,\n      providers: [\n        // Provide the options itself upfront (as we need to inject them as dependencies -- see below)\n        {\n          provide: NotifierOptionsToken,\n          useValue: options,\n        },\n\n        // Provide a custom notifier configuration, based on the given notifier options\n        {\n          deps: [NotifierOptionsToken],\n          provide: NotifierConfigToken,\n          useFactory: notifierCustomConfigFactory,\n        },\n      ],\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}