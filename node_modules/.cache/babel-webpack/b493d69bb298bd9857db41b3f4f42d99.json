{"ast":null,"code":"var _classCallCheck = require(\"/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/@babel/runtime/helpers/createClass\");\n\n/**\n* @license Angular v10.1.0-next.6+7.sha-aaa1d8e\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  (function (_global) {\n    var AsyncTestZoneSpec = /*#__PURE__*/function () {\n      function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        _classCallCheck(this, AsyncTestZoneSpec);\n\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = {\n          'AsyncTestZoneSpec': this\n        };\n        this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n      }\n\n      _createClass(AsyncTestZoneSpec, [{\n        key: \"isUnresolvedChainedPromisePending\",\n        value: function isUnresolvedChainedPromisePending() {\n          return this.unresolvedChainedPromiseCount > 0;\n        }\n      }, {\n        key: \"_finishCallbackIfDone\",\n        value: function _finishCallbackIfDone() {\n          var _this = this;\n\n          if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n            // We do this because we would like to catch unhandled rejected promises.\n            this.runZone.run(function () {\n              setTimeout(function () {\n                if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                  _this.finishCallback();\n                }\n              }, 0);\n            });\n          }\n        }\n      }, {\n        key: \"patchPromiseForTest\",\n        value: function patchPromiseForTest() {\n          if (!this.supportWaitUnresolvedChainedPromise) {\n            return;\n          }\n\n          var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n          if (patchPromiseForTest) {\n            patchPromiseForTest();\n          }\n        }\n      }, {\n        key: \"unPatchPromiseForTest\",\n        value: function unPatchPromiseForTest() {\n          if (!this.supportWaitUnresolvedChainedPromise) {\n            return;\n          }\n\n          var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n          if (unPatchPromiseForTest) {\n            unPatchPromiseForTest();\n          }\n        }\n      }, {\n        key: \"onScheduleTask\",\n        value: function onScheduleTask(delegate, current, target, task) {\n          if (task.type !== 'eventTask') {\n            this._isSync = false;\n          }\n\n          if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n            // check whether the promise is a chained promise\n            if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n              // chained promise is being scheduled\n              this.unresolvedChainedPromiseCount--;\n            }\n          }\n\n          return delegate.scheduleTask(target, task);\n        }\n      }, {\n        key: \"onInvokeTask\",\n        value: function onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n          if (task.type !== 'eventTask') {\n            this._isSync = false;\n          }\n\n          return delegate.invokeTask(target, task, applyThis, applyArgs);\n        }\n      }, {\n        key: \"onCancelTask\",\n        value: function onCancelTask(delegate, current, target, task) {\n          if (task.type !== 'eventTask') {\n            this._isSync = false;\n          }\n\n          return delegate.cancelTask(target, task);\n        } // Note - we need to use onInvoke at the moment to call finish when a test is\n        // fully synchronous. TODO(juliemr): remove this when the logic for\n        // onHasTask changes and it calls whenever the task queues are dirty.\n        // updated by(JiaLiPassion), only call finish callback when no task\n        // was scheduled/invoked/canceled.\n\n      }, {\n        key: \"onInvoke\",\n        value: function onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n          try {\n            this._isSync = true;\n            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n          } finally {\n            var afterTaskCounts = parentZoneDelegate._taskCounts;\n\n            if (this._isSync) {\n              this._finishCallbackIfDone();\n            }\n          }\n        }\n      }, {\n        key: \"onHandleError\",\n        value: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n          // Let the parent try to handle the error.\n          var result = parentZoneDelegate.handleError(targetZone, error);\n\n          if (result) {\n            this.failCallback(error);\n            this._alreadyErrored = true;\n          }\n\n          return false;\n        }\n      }, {\n        key: \"onHasTask\",\n        value: function onHasTask(delegate, current, target, hasTaskState) {\n          delegate.hasTask(target, hasTaskState);\n\n          if (hasTaskState.change == 'microTask') {\n            this._pendingMicroTasks = hasTaskState.microTask;\n\n            this._finishCallbackIfDone();\n          } else if (hasTaskState.change == 'macroTask') {\n            this._pendingMacroTasks = hasTaskState.macroTask;\n\n            this._finishCallbackIfDone();\n          }\n        }\n      }]);\n\n      return AsyncTestZoneSpec;\n    }();\n\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n  })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n      // If we're running using the Jasmine test framework, adapt to call the 'done'\n      // function when asynchronous activity is finished.\n      if (global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n          if (!done) {\n            // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n            // fake it here and assume sync.\n            done = function done() {};\n\n            done.fail = function (e) {\n              throw e;\n            };\n          }\n\n          runInTestZone(fn, this, done, function (err) {\n            if (typeof err === 'string') {\n              return done.fail(new Error(err));\n            } else {\n              done.fail(err);\n            }\n          });\n        };\n      } // Otherwise, return a promise which will resolve when asynchronous activity\n      // is finished. This will be correctly consumed by the Mocha framework with\n      // it('...', async(myFn)); or can be used in a custom framework.\n      // Not using an arrow function to preserve context passed from call site\n\n\n      return function () {\n        var _this2 = this;\n\n        return new Promise(function (finishCallback, failCallback) {\n          runInTestZone(fn, _this2, finishCallback, failCallback);\n        });\n      };\n    };\n\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n      var currentZone = Zone.current;\n      var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n      if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/async-test.js');\n      }\n\n      var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n      if (ProxyZoneSpec === undefined) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n      }\n\n      var proxyZoneSpec = ProxyZoneSpec.get();\n      ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n      // If we do it in ProxyZone then we will get to infinite recursion.\n\n      var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n      var previousDelegate = proxyZoneSpec.getDelegate();\n      proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's\n            // sill this one. Otherwise, assume\n            // it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            finishCallback();\n          });\n        }, function (error) {\n          // Need to restore the original zone.\n          if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n            // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n            proxyZoneSpec.setDelegate(previousDelegate);\n          }\n\n          testZoneSpec.unPatchPromiseForTest();\n          currentZone.run(function () {\n            failCallback(error);\n          });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n        testZoneSpec.patchPromiseForTest();\n      });\n      return Zone.current.runGuarded(fn, context);\n    }\n  });\n});","map":{"version":3,"sources":["/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/zone.js/fesm2015/async-test.js"],"names":["factory","define","amd","_global","AsyncTestZoneSpec","finishCallback","failCallback","namePrefix","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","runZone","Zone","current","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","name","properties","__symbol__","isUnresolvedChainedPromisePending","run","setTimeout","patchPromiseForTest","Promise","unPatchPromiseForTest","delegate","target","task","type","data","symbolParentUnresolved","scheduleTask","applyThis","applyArgs","invokeTask","cancelTask","parentZoneDelegate","currentZone","targetZone","source","invoke","afterTaskCounts","_taskCounts","_finishCallbackIfDone","error","result","handleError","hasTaskState","hasTask","change","microTask","macroTask","window","self","global","__load_patch","api","symbol","asyncTest","fn","jasmine","done","fail","e","runInTestZone","err","Error","context","undefined","ProxyZoneSpec","proxyZoneSpec","get","assertPresent","proxyZone","getZoneWith","previousDelegate","getDelegate","parent","testZoneSpec","setDelegate","runGuarded"],"mappings":"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","sourcesContent":["/**\n* @license Angular v10.1.0-next.6+7.sha-aaa1d8e\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n    factory();\n}((function () { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (_global) {\n        class AsyncTestZoneSpec {\n            constructor(finishCallback, failCallback, namePrefix) {\n                this.finishCallback = finishCallback;\n                this.failCallback = failCallback;\n                this._pendingMicroTasks = false;\n                this._pendingMacroTasks = false;\n                this._alreadyErrored = false;\n                this._isSync = false;\n                this.runZone = Zone.current;\n                this.unresolvedChainedPromiseCount = 0;\n                this.supportWaitUnresolvedChainedPromise = false;\n                this.name = 'asyncTestZone for ' + namePrefix;\n                this.properties = { 'AsyncTestZoneSpec': this };\n                this.supportWaitUnresolvedChainedPromise =\n                    _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n            }\n            isUnresolvedChainedPromisePending() {\n                return this.unresolvedChainedPromiseCount > 0;\n            }\n            _finishCallbackIfDone() {\n                if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                    (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                    // We do this because we would like to catch unhandled rejected promises.\n                    this.runZone.run(() => {\n                        setTimeout(() => {\n                            if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {\n                                this.finishCallback();\n                            }\n                        }, 0);\n                    });\n                }\n            }\n            patchPromiseForTest() {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                const patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n                if (patchPromiseForTest) {\n                    patchPromiseForTest();\n                }\n            }\n            unPatchPromiseForTest() {\n                if (!this.supportWaitUnresolvedChainedPromise) {\n                    return;\n                }\n                const unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n                if (unPatchPromiseForTest) {\n                    unPatchPromiseForTest();\n                }\n            }\n            onScheduleTask(delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                    // check whether the promise is a chained promise\n                    if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                        // chained promise is being scheduled\n                        this.unresolvedChainedPromiseCount--;\n                    }\n                }\n                return delegate.scheduleTask(target, task);\n            }\n            onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            }\n            onCancelTask(delegate, current, target, task) {\n                if (task.type !== 'eventTask') {\n                    this._isSync = false;\n                }\n                return delegate.cancelTask(target, task);\n            }\n            // Note - we need to use onInvoke at the moment to call finish when a test is\n            // fully synchronous. TODO(juliemr): remove this when the logic for\n            // onHasTask changes and it calls whenever the task queues are dirty.\n            // updated by(JiaLiPassion), only call finish callback when no task\n            // was scheduled/invoked/canceled.\n            onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n                try {\n                    this._isSync = true;\n                    return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n                }\n                finally {\n                    const afterTaskCounts = parentZoneDelegate._taskCounts;\n                    if (this._isSync) {\n                        this._finishCallbackIfDone();\n                    }\n                }\n            }\n            onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n                // Let the parent try to handle the error.\n                const result = parentZoneDelegate.handleError(targetZone, error);\n                if (result) {\n                    this.failCallback(error);\n                    this._alreadyErrored = true;\n                }\n                return false;\n            }\n            onHasTask(delegate, current, target, hasTaskState) {\n                delegate.hasTask(target, hasTaskState);\n                if (hasTaskState.change == 'microTask') {\n                    this._pendingMicroTasks = hasTaskState.microTask;\n                    this._finishCallbackIfDone();\n                }\n                else if (hasTaskState.change == 'macroTask') {\n                    this._pendingMacroTasks = hasTaskState.macroTask;\n                    this._finishCallbackIfDone();\n                }\n            }\n        }\n        AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n    })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('asynctest', (global, Zone, api) => {\n        /**\n         * Wraps a test function in an asynchronous test zone. The test will automatically\n         * complete when all asynchronous calls within this zone are done.\n         */\n        Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n            // If we're running using the Jasmine test framework, adapt to call the 'done'\n            // function when asynchronous activity is finished.\n            if (global.jasmine) {\n                // Not using an arrow function to preserve context passed from call site\n                return function (done) {\n                    if (!done) {\n                        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                        // fake it here and assume sync.\n                        done = function () { };\n                        done.fail = function (e) {\n                            throw e;\n                        };\n                    }\n                    runInTestZone(fn, this, done, (err) => {\n                        if (typeof err === 'string') {\n                            return done.fail(new Error(err));\n                        }\n                        else {\n                            done.fail(err);\n                        }\n                    });\n                };\n            }\n            // Otherwise, return a promise which will resolve when asynchronous activity\n            // is finished. This will be correctly consumed by the Mocha framework with\n            // it('...', async(myFn)); or can be used in a custom framework.\n            // Not using an arrow function to preserve context passed from call site\n            return function () {\n                return new Promise((finishCallback, failCallback) => {\n                    runInTestZone(fn, this, finishCallback, failCallback);\n                });\n            };\n        };\n        function runInTestZone(fn, context, finishCallback, failCallback) {\n            const currentZone = Zone.current;\n            const AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n            if (AsyncTestZoneSpec === undefined) {\n                throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/async-test.js');\n            }\n            const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n            if (ProxyZoneSpec === undefined) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/proxy.js');\n            }\n            const proxyZoneSpec = ProxyZoneSpec.get();\n            ProxyZoneSpec.assertPresent();\n            // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n            // If we do it in ProxyZone then we will get to infinite recursion.\n            const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n            const previousDelegate = proxyZoneSpec.getDelegate();\n            proxyZone.parent.run(() => {\n                const testZoneSpec = new AsyncTestZoneSpec(() => {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's\n                        // sill this one. Otherwise, assume\n                        // it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(() => {\n                        finishCallback();\n                    });\n                }, (error) => {\n                    // Need to restore the original zone.\n                    if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                        // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                        proxyZoneSpec.setDelegate(previousDelegate);\n                    }\n                    testZoneSpec.unPatchPromiseForTest();\n                    currentZone.run(() => {\n                        failCallback(error);\n                    });\n                }, 'test');\n                proxyZoneSpec.setDelegate(testZoneSpec);\n                testZoneSpec.patchPromiseForTest();\n            });\n            return Zone.current.runGuarded(fn, context);\n        }\n    });\n\n})));\n"]},"metadata":{},"sourceType":"script"}