{"ast":null,"code":"var _classCallCheck = require(\"/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _construct = require(\"/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/@babel/runtime/helpers/construct\");\n\nvar _toConsumableArray = require(\"/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\n/**\n* @license Angular v10.1.0-next.6+7.sha-aaa1d8e\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  (function (global) {\n    var OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n\n    function FakeDate() {\n      if (arguments.length === 0) {\n        var d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n      } else {\n        var args = Array.prototype.slice.call(arguments);\n        return _construct(OriginalDate, _toConsumableArray(args));\n      }\n    }\n\n    FakeDate.now = function () {\n      var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n      }\n\n      return OriginalDate.now.apply(this, arguments);\n    };\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler = /*#__PURE__*/function () {\n      function Scheduler() {\n        _classCallCheck(this, Scheduler);\n\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTime = 0; // Current real time in millis.\n\n        this._currentRealTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      _createClass(Scheduler, [{\n        key: \"getCurrentTime\",\n        value: function getCurrentTime() {\n          return this._currentTime;\n        }\n      }, {\n        key: \"getCurrentRealTime\",\n        value: function getCurrentRealTime() {\n          return this._currentRealTime;\n        }\n      }, {\n        key: \"setCurrentRealTime\",\n        value: function setCurrentRealTime(realTime) {\n          this._currentRealTime = realTime;\n        }\n      }, {\n        key: \"scheduleFunction\",\n        value: function scheduleFunction(cb, delay, options) {\n          options = Object.assign({\n            args: [],\n            isPeriodic: false,\n            isRequestAnimationFrame: false,\n            id: -1,\n            isRequeuePeriodic: false\n          }, options);\n          var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n          var endTime = this._currentTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n          var newEntry = {\n            endTime: endTime,\n            id: currentId,\n            func: cb,\n            args: options.args,\n            delay: delay,\n            isPeriodic: options.isPeriodic,\n            isRequestAnimationFrame: options.isRequestAnimationFrame\n          };\n\n          if (options.isRequeuePeriodic) {\n            this._currentTickRequeuePeriodicEntries.push(newEntry);\n          }\n\n          var i = 0;\n\n          for (; i < this._schedulerQueue.length; i++) {\n            var currentEntry = this._schedulerQueue[i];\n\n            if (newEntry.endTime < currentEntry.endTime) {\n              break;\n            }\n          }\n\n          this._schedulerQueue.splice(i, 0, newEntry);\n\n          return currentId;\n        }\n      }, {\n        key: \"removeScheduledFunctionWithId\",\n        value: function removeScheduledFunctionWithId(id) {\n          for (var i = 0; i < this._schedulerQueue.length; i++) {\n            if (this._schedulerQueue[i].id == id) {\n              this._schedulerQueue.splice(i, 1);\n\n              break;\n            }\n          }\n        }\n      }, {\n        key: \"tick\",\n        value: function tick() {\n          var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var doTick = arguments.length > 1 ? arguments[1] : undefined;\n          var tickOptions = arguments.length > 2 ? arguments[2] : undefined;\n          var finalTime = this._currentTime + millis;\n          var lastCurrentTime = 0;\n          tickOptions = Object.assign({\n            processNewMacroTasksSynchronously: true\n          }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n          // will not be wrongly called in the current tick\n          // https://github.com/angular/angular/issues/33799\n\n          var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n          if (schedulerQueue.length === 0 && doTick) {\n            doTick(millis);\n            return;\n          }\n\n          while (schedulerQueue.length > 0) {\n            // clear requeueEntries before each loop\n            this._currentTickRequeuePeriodicEntries = [];\n            var current = schedulerQueue[0];\n\n            if (finalTime < current.endTime) {\n              // Done processing the queue since it's sorted by endTime.\n              break;\n            } else {\n              // Time to run scheduled function. Remove it from the head of queue.\n              var _current = schedulerQueue.shift();\n\n              if (!tickOptions.processNewMacroTasksSynchronously) {\n                var idx = this._schedulerQueue.indexOf(_current);\n\n                if (idx >= 0) {\n                  this._schedulerQueue.splice(idx, 1);\n                }\n              }\n\n              lastCurrentTime = this._currentTime;\n              this._currentTime = _current.endTime;\n\n              if (doTick) {\n                doTick(this._currentTime - lastCurrentTime);\n              }\n\n              var retval = _current.func.apply(global, _current.isRequestAnimationFrame ? [this._currentTime] : _current.args);\n\n              if (!retval) {\n                // Uncaught exception in the current scheduled function. Stop processing the queue.\n                break;\n              } // check is there any requeue periodic entry is added in\n              // current loop, if there is, we need to add to current loop\n\n\n              if (!tickOptions.processNewMacroTasksSynchronously) {\n                this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                  var i = 0;\n\n                  for (; i < schedulerQueue.length; i++) {\n                    var currentEntry = schedulerQueue[i];\n\n                    if (newEntry.endTime < currentEntry.endTime) {\n                      break;\n                    }\n                  }\n\n                  schedulerQueue.splice(i, 0, newEntry);\n                });\n              }\n            }\n          }\n\n          lastCurrentTime = this._currentTime;\n          this._currentTime = finalTime;\n\n          if (doTick) {\n            doTick(this._currentTime - lastCurrentTime);\n          }\n        }\n      }, {\n        key: \"flush\",\n        value: function flush() {\n          var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;\n          var flushPeriodic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n          var doTick = arguments.length > 2 ? arguments[2] : undefined;\n\n          if (flushPeriodic) {\n            return this.flushPeriodic(doTick);\n          } else {\n            return this.flushNonPeriodic(limit, doTick);\n          }\n        }\n      }, {\n        key: \"flushPeriodic\",\n        value: function flushPeriodic(doTick) {\n          if (this._schedulerQueue.length === 0) {\n            return 0;\n          } // Find the last task currently queued in the scheduler queue and tick\n          // till that time.\n\n\n          var startTime = this._currentTime;\n          var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n          this.tick(lastTask.endTime - startTime, doTick);\n          return this._currentTime - startTime;\n        }\n      }, {\n        key: \"flushNonPeriodic\",\n        value: function flushNonPeriodic(limit, doTick) {\n          var startTime = this._currentTime;\n          var lastCurrentTime = 0;\n          var count = 0;\n\n          while (this._schedulerQueue.length > 0) {\n            count++;\n\n            if (count > limit) {\n              throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n            } // flush only non-periodic timers.\n            // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n            if (this._schedulerQueue.filter(function (task) {\n              return !task.isPeriodic && !task.isRequestAnimationFrame;\n            }).length === 0) {\n              break;\n            }\n\n            var current = this._schedulerQueue.shift();\n\n            lastCurrentTime = this._currentTime;\n            this._currentTime = current.endTime;\n\n            if (doTick) {\n              // Update any secondary schedulers like Jasmine mock Date.\n              doTick(this._currentTime - lastCurrentTime);\n            }\n\n            var retval = current.func.apply(global, current.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            }\n          }\n\n          return this._currentTime - startTime;\n        }\n      }]);\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec = /*#__PURE__*/function () {\n      function FakeAsyncTestZoneSpec(namePrefix) {\n        var trackPendingRequestAnimationFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var macroTaskOptions = arguments.length > 2 ? arguments[2] : undefined;\n\n        _classCallCheck(this, FakeAsyncTestZoneSpec);\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      _createClass(FakeAsyncTestZoneSpec, [{\n        key: \"_fnAndFlush\",\n        value: function _fnAndFlush(fn, completers) {\n          var _this = this;\n\n          return function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            fn.apply(global, args);\n\n            if (_this._lastError === null) {\n              // Success\n              if (completers.onSuccess != null) {\n                completers.onSuccess.apply(global);\n              } // Flush microtasks only on success.\n\n\n              _this.flushMicrotasks();\n            } else {\n              // Failure\n              if (completers.onError != null) {\n                completers.onError.apply(global);\n              }\n            } // Return true if there were no errors, false otherwise.\n\n\n            return _this._lastError === null;\n          };\n        }\n      }, {\n        key: \"_dequeueTimer\",\n        value: function _dequeueTimer(id) {\n          var _this2 = this;\n\n          return function () {\n            FakeAsyncTestZoneSpec._removeTimer(_this2.pendingTimers, id);\n          };\n        }\n      }, {\n        key: \"_requeuePeriodicTimer\",\n        value: function _requeuePeriodicTimer(fn, interval, args, id) {\n          var _this3 = this;\n\n          return function () {\n            // Requeue the timer callback if it's not been canceled.\n            if (_this3.pendingPeriodicTimers.indexOf(id) !== -1) {\n              _this3._scheduler.scheduleFunction(fn, interval, {\n                args: args,\n                isPeriodic: true,\n                id: id,\n                isRequeuePeriodic: true\n              });\n            }\n          };\n        }\n      }, {\n        key: \"_dequeuePeriodicTimer\",\n        value: function _dequeuePeriodicTimer(id) {\n          var _this4 = this;\n\n          return function () {\n            FakeAsyncTestZoneSpec._removeTimer(_this4.pendingPeriodicTimers, id);\n          };\n        }\n      }, {\n        key: \"_setTimeout\",\n        value: function _setTimeout(fn, delay, args) {\n          var isTimer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n          var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n          var cb = this._fnAndFlush(fn, {\n            onSuccess: removeTimerFn,\n            onError: removeTimerFn\n          });\n\n          var id = this._scheduler.scheduleFunction(cb, delay, {\n            args: args,\n            isRequestAnimationFrame: !isTimer\n          });\n\n          if (isTimer) {\n            this.pendingTimers.push(id);\n          }\n\n          return id;\n        }\n      }, {\n        key: \"_clearTimeout\",\n        value: function _clearTimeout(id) {\n          FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n          this._scheduler.removeScheduledFunctionWithId(id);\n        }\n      }, {\n        key: \"_setInterval\",\n        value: function _setInterval(fn, interval, args) {\n          var id = Scheduler.nextId;\n          var completers = {\n            onSuccess: null,\n            onError: this._dequeuePeriodicTimer(id)\n          };\n\n          var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n          completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n          this._scheduler.scheduleFunction(cb, interval, {\n            args: args,\n            isPeriodic: true\n          });\n\n          this.pendingPeriodicTimers.push(id);\n          return id;\n        }\n      }, {\n        key: \"_clearInterval\",\n        value: function _clearInterval(id) {\n          FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n          this._scheduler.removeScheduledFunctionWithId(id);\n        }\n      }, {\n        key: \"_resetLastErrorAndThrow\",\n        value: function _resetLastErrorAndThrow() {\n          var error = this._lastError || this._uncaughtPromiseErrors[0];\n          this._uncaughtPromiseErrors.length = 0;\n          this._lastError = null;\n          throw error;\n        }\n      }, {\n        key: \"getCurrentTime\",\n        value: function getCurrentTime() {\n          return this._scheduler.getCurrentTime();\n        }\n      }, {\n        key: \"getCurrentRealTime\",\n        value: function getCurrentRealTime() {\n          return this._scheduler.getCurrentRealTime();\n        }\n      }, {\n        key: \"setCurrentRealTime\",\n        value: function setCurrentRealTime(realTime) {\n          this._scheduler.setCurrentRealTime(realTime);\n        }\n      }, {\n        key: \"lockDatePatch\",\n        value: function lockDatePatch() {\n          this.patchDateLocked = true;\n          FakeAsyncTestZoneSpec.patchDate();\n        }\n      }, {\n        key: \"unlockDatePatch\",\n        value: function unlockDatePatch() {\n          this.patchDateLocked = false;\n          FakeAsyncTestZoneSpec.resetDate();\n        }\n      }, {\n        key: \"tick\",\n        value: function tick() {\n          var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          var doTick = arguments.length > 1 ? arguments[1] : undefined;\n          var tickOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n            processNewMacroTasksSynchronously: true\n          };\n          FakeAsyncTestZoneSpec.assertInZone();\n          this.flushMicrotasks();\n\n          this._scheduler.tick(millis, doTick, tickOptions);\n\n          if (this._lastError !== null) {\n            this._resetLastErrorAndThrow();\n          }\n        }\n      }, {\n        key: \"flushMicrotasks\",\n        value: function flushMicrotasks() {\n          var _this5 = this;\n\n          FakeAsyncTestZoneSpec.assertInZone();\n\n          var flushErrors = function flushErrors() {\n            if (_this5._lastError !== null || _this5._uncaughtPromiseErrors.length) {\n              // If there is an error stop processing the microtask queue and rethrow the error.\n              _this5._resetLastErrorAndThrow();\n            }\n          };\n\n          while (this._microtasks.length > 0) {\n            var microtask = this._microtasks.shift();\n\n            microtask.func.apply(microtask.target, microtask.args);\n          }\n\n          flushErrors();\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(limit, flushPeriodic, doTick) {\n          FakeAsyncTestZoneSpec.assertInZone();\n          this.flushMicrotasks();\n\n          var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n          if (this._lastError !== null) {\n            this._resetLastErrorAndThrow();\n          }\n\n          return elapsed;\n        }\n      }, {\n        key: \"onScheduleTask\",\n        value: function onScheduleTask(delegate, current, target, task) {\n          switch (task.type) {\n            case 'microTask':\n              var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n              // currently we know process.nextTick will have such additional\n              // arguments\n\n              var additionalArgs;\n\n              if (args) {\n                var callbackIndex = task.data.cbIdx;\n\n                if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                  additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                }\n              }\n\n              this._microtasks.push({\n                func: task.invoke,\n                args: additionalArgs,\n                target: task.data && task.data.target\n              });\n\n              break;\n\n            case 'macroTask':\n              switch (task.source) {\n                case 'setTimeout':\n                  task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                  break;\n\n                case 'setImmediate':\n                  task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                  break;\n\n                case 'setInterval':\n                  task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                  break;\n\n                case 'XMLHttpRequest.send':\n                  throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n                case 'requestAnimationFrame':\n                case 'webkitRequestAnimationFrame':\n                case 'mozRequestAnimationFrame':\n                  // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                  // (60 frames per second)\n                  task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                  break;\n\n                default:\n                  // user can define which macroTask they want to support by passing\n                  // macroTaskOptions\n                  var macroTaskOption = this.findMacroTaskOption(task);\n\n                  if (macroTaskOption) {\n                    var _args = task.data && task.data['args'];\n\n                    var delay = _args && _args.length > 1 ? _args[1] : 0;\n                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : _args;\n\n                    if (!!macroTaskOption.isPeriodic) {\n                      // periodic macroTask, use setInterval to simulate\n                      task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                      task.data.isPeriodic = true;\n                    } else {\n                      // not periodic, use setTimeout to simulate\n                      task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                    }\n\n                    break;\n                  }\n\n                  throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n              }\n\n              break;\n\n            case 'eventTask':\n              task = delegate.scheduleTask(target, task);\n              break;\n          }\n\n          return task;\n        }\n      }, {\n        key: \"onCancelTask\",\n        value: function onCancelTask(delegate, current, target, task) {\n          switch (task.source) {\n            case 'setTimeout':\n            case 'requestAnimationFrame':\n            case 'webkitRequestAnimationFrame':\n            case 'mozRequestAnimationFrame':\n              return this._clearTimeout(task.data['handleId']);\n\n            case 'setInterval':\n              return this._clearInterval(task.data['handleId']);\n\n            default:\n              // user can define which macroTask they want to support by passing\n              // macroTaskOptions\n              var macroTaskOption = this.findMacroTaskOption(task);\n\n              if (macroTaskOption) {\n                var handleId = task.data['handleId'];\n                return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n              }\n\n              return delegate.cancelTask(target, task);\n          }\n        }\n      }, {\n        key: \"onInvoke\",\n        value: function onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n          try {\n            FakeAsyncTestZoneSpec.patchDate();\n            return delegate.invoke(target, callback, applyThis, applyArgs, source);\n          } finally {\n            if (!this.patchDateLocked) {\n              FakeAsyncTestZoneSpec.resetDate();\n            }\n          }\n        }\n      }, {\n        key: \"findMacroTaskOption\",\n        value: function findMacroTaskOption(task) {\n          if (!this.macroTaskOptions) {\n            return null;\n          }\n\n          for (var i = 0; i < this.macroTaskOptions.length; i++) {\n            var macroTaskOption = this.macroTaskOptions[i];\n\n            if (macroTaskOption.source === task.source) {\n              return macroTaskOption;\n            }\n          }\n\n          return null;\n        }\n      }, {\n        key: \"onHandleError\",\n        value: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n          this._lastError = error;\n          return false; // Don't propagate error to parent zone.\n        }\n      }], [{\n        key: \"assertInZone\",\n        value: function assertInZone() {\n          if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n            throw new Error('The code should be running in the fakeAsync zone to call this function');\n          }\n        }\n      }, {\n        key: \"_removeTimer\",\n        value: function _removeTimer(timers, id) {\n          var index = timers.indexOf(id);\n\n          if (index > -1) {\n            timers.splice(index, 1);\n          }\n        }\n      }, {\n        key: \"patchDate\",\n        value: function patchDate() {\n          if (!!global[Zone.__symbol__('disableDatePatching')]) {\n            // we don't want to patch global Date\n            // because in some case, global Date\n            // is already being patched, we need to provide\n            // an option to let user still use their\n            // own version of Date.\n            return;\n          }\n\n          if (global['Date'] === FakeDate) {\n            // already patched\n            return;\n          }\n\n          global['Date'] = FakeDate;\n          FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n          // because jasmine.clock().install() may\n          // have replaced the global timer\n\n          FakeAsyncTestZoneSpec.checkTimerPatch();\n        }\n      }, {\n        key: \"resetDate\",\n        value: function resetDate() {\n          if (global['Date'] === FakeDate) {\n            global['Date'] = OriginalDate;\n          }\n        }\n      }, {\n        key: \"checkTimerPatch\",\n        value: function checkTimerPatch() {\n          if (global.setTimeout !== timers.setTimeout) {\n            global.setTimeout = timers.setTimeout;\n            global.clearTimeout = timers.clearTimeout;\n          }\n\n          if (global.setInterval !== timers.setInterval) {\n            global.setInterval = timers.setInterval;\n            global.clearInterval = timers.clearInterval;\n          }\n        }\n      }]);\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone && Zone['ProxyZoneSpec'];\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      return function () {\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick() {\n      var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var ignoreNestedTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      var pendingTimers = zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  });\n});","map":{"version":3,"sources":["/home/brsoft/Desktop/My data/Desktop/maiapayadmin/node_modules/zone.js/fesm2015/fake-async-test.js"],"names":["factory","define","amd","global","OriginalDate","Date","FakeDate","arguments","length","d","setTime","now","args","Array","prototype","slice","call","fakeAsyncTestZoneSpec","Zone","current","get","getCurrentRealTime","getCurrentTime","apply","UTC","parse","timers","setTimeout","setInterval","clearTimeout","clearInterval","Scheduler","_schedulerQueue","_currentTime","_currentRealTime","_currentTickRequeuePeriodicEntries","realTime","cb","delay","options","Object","assign","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","push","i","currentEntry","splice","millis","doTick","tickOptions","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","shift","idx","indexOf","retval","forEach","limit","flushPeriodic","flushNonPeriodic","startTime","lastTask","tick","count","Error","filter","task","FakeAsyncTestZoneSpec","namePrefix","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","Promise","__symbol__","pendingPeriodicTimers","pendingTimers","patchDateLocked","properties","name","fn","completers","onSuccess","flushMicrotasks","onError","_removeTimer","interval","scheduleFunction","isTimer","removeTimerFn","_dequeueTimer","_fnAndFlush","removeScheduledFunctionWithId","_dequeuePeriodicTimer","_requeuePeriodicTimer","error","setCurrentRealTime","patchDate","resetDate","assertInZone","_resetLastErrorAndThrow","flushErrors","microtask","target","elapsed","flush","delegate","type","data","additionalArgs","callbackIndex","cbIdx","invoke","source","_setTimeout","_setInterval","macroTaskOption","findMacroTaskOption","callbackArgs","scheduleTask","_clearTimeout","_clearInterval","handleId","cancelTask","callback","applyThis","applyArgs","parentZoneDelegate","currentZone","targetZone","index","checkTimerPatch","window","self","__load_patch","api","ProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","unlockDatePatch","assertPresent","resetDelegate","fakeAsync","proxyZoneSpec","getDelegate","res","lastProxyZoneSpec","setDelegate","lockDatePatch","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","zoneSpec","symbol"],"mappings":"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","sourcesContent":["/**\n* @license Angular v10.1.0-next.6+7.sha-aaa1d8e\n* (c) 2010-2020 Google LLC. https://angular.io/\n* License: MIT\n*/\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n    factory();\n}((function () { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        const OriginalDate = global.Date;\n        // Since when we compile this file to `es2015`, and if we define\n        // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n        // there will be an error which is `Cannot assign to read only property 'prototype'`\n        // so we need to use function implementation here.\n        function FakeDate() {\n            if (arguments.length === 0) {\n                const d = new OriginalDate();\n                d.setTime(FakeDate.now());\n                return d;\n            }\n            else {\n                const args = Array.prototype.slice.call(arguments);\n                return new OriginalDate(...args);\n            }\n        }\n        FakeDate.now =\n            function () {\n                const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncTestZoneSpec) {\n                    return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n                }\n                return OriginalDate.now.apply(this, arguments);\n            };\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        const timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        class Scheduler {\n            constructor() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTime = 0;\n                // Current real time in millis.\n                this._currentRealTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            getCurrentTime() {\n                return this._currentTime;\n            }\n            getCurrentRealTime() {\n                return this._currentRealTime;\n            }\n            setCurrentRealTime(realTime) {\n                this._currentRealTime = realTime;\n            }\n            scheduleFunction(cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                let currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                let endTime = this._currentTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                let newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                let i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    let currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            }\n            removeScheduledFunctionWithId(id) {\n                for (let i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n            tick(millis = 0, doTick, tickOptions) {\n                let finalTime = this._currentTime + millis;\n                let lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    let current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        let current = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            const idx = this._schedulerQueue.indexOf(current);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTime;\n                        this._currentTime = current.endTime;\n                        if (doTick) {\n                            doTick(this._currentTime - lastCurrentTime);\n                        }\n                        let retval = current.func.apply(global, current.isRequestAnimationFrame ? [this._currentTime] : current.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(newEntry => {\n                                let i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    const currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTime;\n                this._currentTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTime - lastCurrentTime);\n                }\n            }\n            flush(limit = 20, flushPeriodic = false, doTick) {\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            }\n            flushPeriodic(doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                const startTime = this._currentTime;\n                const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTime - startTime;\n            }\n            flushNonPeriodic(limit, doTick) {\n                const startTime = this._currentTime;\n                let lastCurrentTime = 0;\n                let count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(task => !task.isPeriodic && !task.isRequestAnimationFrame)\n                        .length === 0) {\n                        break;\n                    }\n                    const current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTime;\n                    this._currentTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTime - lastCurrentTime);\n                    }\n                    const retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTime - startTime;\n            }\n        }\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        class FakeAsyncTestZoneSpec {\n            constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            static assertInZone() {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            _fnAndFlush(fn, completers) {\n                return (...args) => {\n                    fn.apply(global, args);\n                    if (this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return this._lastError === null;\n                };\n            }\n            static _removeTimer(timers, id) {\n                let index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            }\n            _dequeueTimer(id) {\n                return () => {\n                    FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                };\n            }\n            _requeuePeriodicTimer(fn, interval, args, id) {\n                return () => {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        this._scheduler.scheduleFunction(fn, interval, { args, isPeriodic: true, id, isRequeuePeriodic: true });\n                    }\n                };\n            }\n            _dequeuePeriodicTimer(id) {\n                return () => {\n                    FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                };\n            }\n            _setTimeout(fn, delay, args, isTimer = true) {\n                let removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                let cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                let id = this._scheduler.scheduleFunction(cb, delay, { args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            }\n            _clearTimeout(id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            }\n            _setInterval(fn, interval, args) {\n                let id = Scheduler.nextId;\n                let completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                let cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            }\n            _clearInterval(id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            }\n            _resetLastErrorAndThrow() {\n                let error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            }\n            getCurrentTime() {\n                return this._scheduler.getCurrentTime();\n            }\n            getCurrentRealTime() {\n                return this._scheduler.getCurrentRealTime();\n            }\n            setCurrentRealTime(realTime) {\n                this._scheduler.setCurrentRealTime(realTime);\n            }\n            static patchDate() {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            }\n            static resetDate() {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            }\n            static checkTimerPatch() {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            }\n            lockDatePatch() {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            }\n            unlockDatePatch() {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            }\n            tick(millis = 0, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            }\n            flushMicrotasks() {\n                FakeAsyncTestZoneSpec.assertInZone();\n                const flushErrors = () => {\n                    if (this._lastError !== null || this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    let microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            }\n            flush(limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            }\n            onScheduleTask(delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        let args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        let additionalArgs;\n                        if (args) {\n                            let callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                const macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    const args = task.data && task.data['args'];\n                                    const delay = args && args.length > 1 ? args[1] : 0;\n                                    let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            }\n            onCancelTask(delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        const macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            const handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            }\n            onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            }\n            findMacroTaskOption(task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (let i = 0; i < this.macroTaskOptions.length; i++) {\n                    const macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            }\n            onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            }\n        }\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('fakeasync', (global, Zone, api) => {\n        const FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        const ProxyZoneSpec = Zone && Zone['ProxyZoneSpec'];\n        let _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            return function (...args) {\n                const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    let res;\n                    const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n                            `periodic timer(s) still in the queue.`);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis = 0, ignoreNestedTimeout = false) {\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) {\n            return _getFakeAsyncZoneSpec().flush(maxTurns);\n        }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            const zoneSpec = _getFakeAsyncZoneSpec();\n            const pendingTimers = zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() {\n            _getFakeAsyncZoneSpec().flushMicrotasks();\n        }\n        Zone[api.symbol('fakeAsyncTest')] =\n            { resetFakeAsyncZone, flushMicrotasks, discardPeriodicTasks, tick, flush, fakeAsync };\n    });\n\n})));\n"]},"metadata":{},"sourceType":"script"}